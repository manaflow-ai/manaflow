// This file is auto-generated by @hey-api/openapi-ts

export type AccessLevel = 'read' | 'write';

export type AccessTokenInfo = {
    id: string;
};

/**
 * Identical to [`RepositoryInfo`], but with the permissions field added.
 */
export type AccessibleRepository = {
    id: string;
    name?: string | null;
    accountId: string;
    permissions: AccessLevel;
    visibility: Visibility;
};

export type AdditionalRepository = {
    repositoryId: string;
    path: string;
};

export type Behavior = 'regex' | 'exact';

/**
 * The encoding of a blob from the API. Always `base64`.
 */
export type BlobEncoding = 'base64';

/**
 * Blob object
 */
export type BlobObject = {
    /**
     * The content of the blob, base64 encoded.
     */
    content: string;
    /**
     * The encoding of the blob. Always `base64`.
     */
    encoding: BlobEncoding;
    /**
     * The object's hash.
     */
    sha: string;
    /**
     * The blob's size in bytes
     */
    size: number;
};

export type BranchDetails = {
    default: boolean;
    name: string;
    target?: string | null;
};

export type BranchInfo = {
    name: string;
    /**
     * The latest commit ID on this branch. Null if the branch is empty.
     */
    commit?: string | null;
};

/**
 * Response containing the comparison between two commits
 */
export type CommitComparison = {
    /**
     * Status of the comparison
     */
    status: ComparisonStatus;
    /**
     * Number of commits the head is ahead of base
     */
    ahead_by: number;
    /**
     * Number of commits the head is behind base
     */
    behind_by: number;
    /**
     * Total number of commits in the comparison
     */
    total_commits: number;
    /**
     * List of changed files
     */
    files: Array<DiffFile>;
};

export type CommitList = {
    /**
     * List of commits
     */
    commits: Array<CommitObject>;
    /**
     * Number of commits returned in this page
     */
    count: number;
    /**
     * Number of commits skipped (offset)
     */
    offset: number;
    /**
     * Maximum number of commits requested (limit)
     */
    limit: number;
    /**
     * Total number of commits available in the branch
     */
    total: number;
};

/**
 * Commit object
 */
export type CommitObject = {
    /**
     * The author of the commit
     */
    author: Signature;
    /**
     * The committer
     */
    committer: Signature;
    /**
     * The commit message
     */
    message: string;
    /**
     * The ID of the tree pointed to by this commit
     */
    tree: CommitTree;
    /**
     * Parent commit(s) of this commit
     */
    parents: Array<CommitParent>;
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitParent = {
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitTree = {
    /**
     * The tree's hash ID
     */
    sha: string;
};

/**
 * The status of a commit comparison
 */
export type ComparisonStatus = 'identical' | 'ahead' | 'behind' | 'diverged';

export type ConfigureGithubSyncRequest = {
    /**
     * The GitHub repository name in "owner/repo" format
     */
    githubRepoName: string;
};

export type CreateDomainMappingRequest = {
    deploymentId: string;
};

export type CreateRecordParams = {
    domain: string;
    record: DnsRecordData;
};

export type CreateRecordResponse = {
    record: DnsRecord;
};

export type CreateRepoImport = {
    /**
     * Files
     * A map of file names to their contents.
     */
    files: {
        [key: string]: string;
    };
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'files';
} | {
    url: string;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'tar';
} | {
    url: string;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'zip';
} | {
    url: string;
    branch?: string | null;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'git';
};

export type CreateRepoRequest = {
    source?: null | CreateRepoSource;
    import?: null | CreateRepoImport;
    defaultBranch?: string | null;
};

export type CreateRepoSource = {
    url: string;
    branch?: string | null;
    depth?: number | null;
};

export type CreateRepositoryRequest = {
    /**
     * This name is not visible to users, and is only accessible to you via API and in the
     * dashboard. Mostly useful for observability.
     */
    name?: string | null;
    public?: boolean;
    /**
     * The default branch name for the repository. Defaults to "main" if not specified.
     */
    defaultBranch?: string | null;
    /**
     * Fork from another Git repository. Cannot be used with `import`.
     */
    source?: CreateRepoSource;
    /**
     * Import static content with an initial commit. Cannot be used with `source`.
     */
    import?: CreateRepoImport;
    devServers?: DevServerConfiguration;
};

export type CreateRepositoryResponseSuccess = {
    repoId: string;
};

export type CreateSnapshotRequest = {
    name?: string | null;
    template: VmTemplate;
};

export type CreateSnapshotResponse = {
    snapshotId: VmShortId;
};

export type CreateVmRequest = {
    idleTimeoutSeconds?: number | null;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000
     * will be exposed on port 443 by default. Pass an empty array to disable
     * external ports. Only ports 8081 and 443 can be configured externally for
     * now. Any target port is allowed.
     */
    ports?: Array<PortMapping> | null;
    /**
     * Whether the api request should wait for the VM to be ready before
     * returning. By default, the VM is considered ready when the serial
     * console is ready for login.
     */
    waitForReadySignal?: boolean | null;
    /**
     * How long to wait for the ready signal before timing out. Defaults to 120
     * seconds if not provided.
     */
    readySignalTimeoutSeconds?: number | null;
    /**
     * Optional working directory for the VM. File system and shell commands
     * will be executed in this directory.
     */
    workdir?: string | null;
    persistence?: null | VmPersistence;
    systemd?: null | SystemdConfig;
    users?: Array<LinuxUserSpec> | null;
    groups?: Array<LinuxGroupSpec> | null;
    additionalFiles?: {
        [key: string]: FreestyleFile;
    } | null;
    snapshotId?: string | null;
    template?: null | VmTemplate;
    gitRepos?: Array<GitRepositorySpec> | null;
    /**
     * If true, the VM can be recreated if it is deleted. The VM will keep the same ID
     * and be recreated with the same configuration when something tries to start it.
     */
    recreate?: boolean | null;
    /**
     * Optional list of apt packages to install when setting up the VM.
     * These packages will be installed using `apt-get install` on VM startup.
     */
    aptDeps?: Array<string> | null;
};

export type CreateVmResponse = {
    id: string;
    domains: Array<string>;
    consoleUrl?: string | null;
};

export type CreatedToken = {
    id: string;
    token: string;
};

export type CustomBuildOptions = {
    command: string;
    outDir?: string | null;
    envVars?: {
        [key: string]: string;
    } | null;
};

export type DeleteRecordResponse = {
    message: string;
};

export type DeleteRepositorySuccess = {
    [key: string]: unknown;
};

export type DeleteVmResponses = {
    id: string;
};

export type DeploymentBuildOptions = boolean | CustomBuildOptions;

export type DeploymentLogEntry = {
    deploymentId: string;
    accountId: string;
    provisionedAt: string;
    timeout: string;
    state: DeploymentState;
    deployedAt?: string | null;
    domains: Array<string>;
    envVars: {
        [key: string]: string;
    };
};

export type DeploymentSource = {
    files: {
        [key: string]: FreestyleFile;
    };
    kind: 'files';
} | {
    url: string;
    kind: 'tar';
} | {
    url: string;
    branch?: string | null;
    dir?: string | null;
    kind: 'git';
};

export type DeploymentState = 'provisioning' | 'deployed' | 'failed';

export type DescribeGitPermissionSuccess = {
    identity: string;
    repo: string;
    accessLevel?: null | AccessLevel;
};

export type DevServerConfiguration = {
    devCommand?: string | null;
    installCommand?: string | null;
    timeout?: number | null;
    envVars?: {
        [key: string]: string;
    } | null;
    ports?: Array<PortConfig> | null;
    preset?: null | DevServerPreset;
    systemd?: null | SystemdConfigInternal;
    users?: Array<LinuxUserSpec> | null;
    groups?: Array<LinuxGroupSpec> | null;
    additionalFiles?: {
        [key: string]: FreestyleFile;
    } | null;
    webTerminal?: boolean | null;
    webVscode?: boolean | null;
    additionalRepositories?: Array<AdditionalRepository> | null;
};

export type DevServerIdentifier = {
    repoId: string;
    gitRef?: string | null;
};

export type DevServerLogsRequest = {
    devServer: DevServerIdentifier;
    lines?: number | null;
};

export type DevServerPreset = 'auto' | 'nextJs' | 'vite' | 'expo';

export type DevServerRequest = DevServerConfiguration & {
    repoId?: string | null;
    computeClass?: string | null;
    /**
     * @deprecated
     */
    domain?: string | null;
    /**
     * @deprecated
     */
    repo?: string | null;
    gitRef?: string | null;
    preDevCommandOnce?: string | null;
    /**
     * @deprecated
     */
    baseId?: string | null;
};

export type DevServerRequestV2 = (null | DevServerConfiguration) & {
    repoId?: string | null;
    gitRef?: string | null;
    /**
     * By default dev servers will find a matching session, with forceNew is true it will always create a new one
     */
    forceNew?: boolean | null;
};

export type DevServerRestartRequest = {
    devServer: DevServerIdentifier;
};

export type DevServerStatusRequest = {
    devServer: DevServerIdentifier;
};

export type DevServerWatchFilesRequest = {
    devServer: DevServerIdentifier;
};

/**
 * A file that was changed in the comparison
 */
export type DiffFile = {
    /**
     * The blob SHA of the file
     */
    sha?: string | null;
    /**
     * The file path
     */
    filename: string;
    /**
     * The status of the file (added, removed, modified, renamed, copied, changed, unchanged)
     */
    status: DiffFileStatus;
    /**
     * Number of lines added
     */
    additions: number;
    /**
     * Number of lines deleted
     */
    deletions: number;
    /**
     * Total number of changes (additions + deletions)
     */
    changes: number;
    /**
     * Previous filename (for renamed/copied files)
     */
    previous_filename?: string | null;
};

/**
 * The status of a file in a diff
 */
export type DiffFileStatus = 'added' | 'removed' | 'modified' | 'renamed' | 'copied' | 'changed' | 'unchanged';

export type DnsRecord = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl: string;
    priority?: number | null;
    managed: boolean;
};

export type DnsRecordData = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl?: string | null;
    priority?: number | null;
};

export type DnsRecordKind = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'NS';

export type DomainVerificationRequest = {
    id: string;
    domain: string;
    accountId: string;
    verificationCode: string;
    createdAt: string;
};

export type EmptyResponse = {
    [key: string]: unknown;
};

export type ErrorResponse = {
    message: string;
};

export type ExecAwaitRequest = {
    command: string;
    terminal?: string | null;
    timeoutMs?: number | null;
};

export type ExecAwaitVmResponse = {
    stdout?: string | null;
    stderr?: string | null;
    statusCode?: number | null;
};

export type ExecRequest = {
    devServer: DevServerIdentifier;
    command: string;
    /**
     * Spawn this command as a background process and return immediately
     */
    background: boolean;
};

export type ExecuteLogEntry = {
    deployment: string;
    accountId: string;
    provisionedAt: string;
    startedAt?: string | null;
    duration?: string | null;
    state: ExecuteRunState;
    envVars: {
        [key: string]: string;
    };
};

export type ExecuteRunInfo = {
    code: string;
    nodeModules: {
        [key: string]: string;
    };
};

export type ExecuteRunState = 'starting' | 'running' | 'complete';

export type FileInfo = {
    name: string;
    kind: string;
};

export type FileSystemResponse = {
    content: string;
} | {
    files: Array<FileInfo>;
};

export type ForkVmRequest = {
    idleTimeoutSeconds?: number | null;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000
     * will be exposed on port 443 by default. Pass an empty array to disable
     * external ports. Only ports 8081 and 443 can be configured externally for
     * now. Any target port is allowed.
     */
    ports?: Array<PortMapping> | null;
    /**
     * Whether the api request should wait for the VM to be ready before
     * returning. By default, the VM is considered ready when the serial
     * console is ready for login.
     */
    readySignalTimeoutSeconds?: number | null;
    /**
     * How long to wait for the ready signal before timing out. Defaults to 120
     * seconds if not provided.
     */
    waitForReadySignal?: boolean | null;
    /**
     * Optional working directory for the VM. File system and shell commands
     * will be executed in this directory.
     */
    workdir?: string | null;
    persistence?: null | VmPersistence;
};

export type ForkVmResponse = {
    id: string;
    domains: Array<string>;
    console_url?: string | null;
};

export type FreestyleCloudstateDeployConfiguration = {
    /**
     * ID of the project to deploy, if not provided will create a new project
     */
    domains?: Array<string> | null;
    /**
     * The environment variables that the cloudstate deploy can access
     */
    envVars?: {
        [key: string]: string;
    };
    cloudstateDatabaseId?: string | null;
};

export type FreestyleCloudstateDeployErrorResponse = {
    message: string;
};

export type FreestyleCloudstateDeployRequest = {
    classes: string;
    config?: FreestyleCloudstateDeployConfiguration;
};

export type FreestyleCloudstateDeploySuccessResponse = {
    deploymentId: string;
    cloudstateDatabaseId: string;
};

export type FreestyleDeleteDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
    /**
     * The verification code
     */
    verificationCode: string;
};

export type FreestyleDeployWebConfiguration = {
    domains?: Array<string> | null;
    entrypoint?: string | null;
    envVars?: {
        [key: string]: string;
    } | null;
    nodeModules?: {
        [key: string]: string;
    } | null;
    timeout?: number | null;
    serverStartCheck?: boolean | null;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    build?: null | DeploymentBuildOptions;
    await?: boolean | null;
};

export type FreestyleDeployWebErrorResponse = {
    message: string;
};

export type FreestyleDeployWebPayload = {
    /**
     * The files to deploy, a map of file paths to file contents, e.g. { \"index.js\": {\"content\": \"your main\", \"encoding\": \"utf-8\"}, \"file2.js\": {\"content\": \"your helper\" } }
     *
     * **Do not include node modules in this bundle, they will not work**. Instead, includes a package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock, the node modules for the project will be installed from that lock file, or use the node_modules field in the configuration to specify the node modules to install.
     */
    files: {
        [key: string]: FreestyleFile;
    };
    config?: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebPayloadV2 = {
    source: DeploymentSource;
    config: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebSuccessResponseV2 = {
    deploymentId: string;
    /**
     * @deprecated
     */
    projectId: string;
    domains?: Array<string> | null;
    /**
     * The entrypoint file for the website. If not specified we try to automatically detect it.
     */
    entrypoint: string;
} | {
    deploymentId: string;
};

export type FreestyleDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
};

export type FreestyleExecuteScriptParams = {
    /**
     * The JavaScript or TypeScript script to execute
     */
    script: string;
    config?: FreestyleExecuteScriptParamsConfiguration;
};

export type FreestyleExecuteScriptParamsConfiguration = {
    /**
     * The environment variables to set for the script
     */
    envVars?: {
        [key: string]: string;
    };
    /**
     * The node modules to install for the script
     */
    nodeModules?: {
        [key: string]: string;
    };
    /**
     * Tags for you to organize your scripts, useful for tracking what you're running
     */
    tags?: Array<string>;
    /**
     * The script timeout
     */
    timeout?: number | null;
    /**
     * If false, we'll not resolve peer dependencies for the packages given, this can speed up execute performance, but will break packages with peers unless the peers are manually specified.
     */
    peerDependencyResolution?: boolean;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    /**
     * These headers will be added to every fetch request made through the script
     */
    customHeaders?: {
        [key: string]: string;
    };
    /**
     * Proxy all outgoing requests through this URL
     */
    proxy?: string | null;
};

export type FreestyleExecuteScriptResultSuccess = {
    /**
     * The return value of the default export of the script
     */
    result: unknown;
    logs: Array<FreestyleJavaScriptLog>;
};

export type FreestyleFile = {
    /**
     * The content of the file
     */
    content: string;
    /**
     * The encoding of the file. Either **utf-8** or **base64**
     */
    encoding?: string;
};

export type FreestyleGetLogsResponse = {
    logs: Array<FreestyleLogResponseObject>;
    nextPageToken?: string | null;
};

export type FreestyleIdentity = {
    id: string;
    managed: boolean;
};

export type FreestyleJavaScriptLog = {
    /**
     * The log message
     */
    message: string;
    /**
     * The log level
     */
    type: string;
};

export type FreestyleLogResponseObject = {
    message: string;
    timestamp: string;
};

export type FreestyleNetworkPermission = (NetworkPermissionData & {
    action: 'allow';
}) | (NetworkPermissionData & {
    action: 'deny';
});

export type FreestyleSandboxDomainMapping = {
    id: string;
    domain: string;
    deploymentId: string;
    ownershipId: string;
    createdAt: string;
};

/**
 * Verify a domain verification request, can either be done for a domain, or for a specific request
 */
export type FreestyleVerifyDomainRequest = {
    domain: string;
} | {
    id: string;
};

export type GetDefaultBranchResponse = {
    defaultBranch: string;
};

export type GetVmResponse = {
    id: string;
    lastNetworkActivity?: string | null;
    state?: null | VmState;
    cpuTimeSeconds?: number | null;
};

export type GitCommitPushRequest = {
    devServer: DevServerIdentifier;
    message: string;
};

export type GitCommitPushResponse = {
    committed: boolean;
    pushed: boolean;
};

export type GitContents = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    /**
     * Base64-encoded content.
     */
    content: string;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<GitContentsDirEntryItem>;
    type: 'dir';
};

export type GitContentsDirEntryItem = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<{
        [key: string]: unknown;
    } | {
        [key: string]: unknown;
    }>;
    type: 'dir';
};

/**
 * A reference to a Git object
 */
export type GitReference = {
    /**
     * The name of the ref (e.g., "refs/heads/main" or "refs/tags/v1.0.0")
     */
    name: string;
    /**
     * The SHA-1 hash of the Git object this reference points to
     */
    sha: string;
};

export type GitRepositorySpec = {
    /**
     * url or id of the git repository
     */
    repo: string;
    /**
     * path to place the repo on
     */
    path: string;
    /**
     * optional rev (branch, tag, commit)
     */
    rev?: string | null;
};

export type GitRepositoryTrigger = {
    repositoryId: string;
    trigger: {
        branches?: Array<string> | null;
        globs?: Array<string> | null;
        event: 'push';
    };
    action: {
        endpoint: string;
        action: 'webhook';
    };
    managed: boolean;
    id: string;
    createdAt: string;
};

export type GitTrigger = {
    branches?: Array<string> | null;
    globs?: Array<string> | null;
    event: 'push';
};

export type GitTriggerAction = {
    endpoint: string;
    action: 'webhook';
};

export type GithubRepoSyncConfig = {
    freestyleRepoId: string;
    accountId: string;
    installationId: number;
    githubRepoId: number;
    githubRepoName: string;
    createdAt: string;
};

export type GithubSyncConfigResponse = {
    githubRepoName: string;
};

export type GrantGitPermissionRequest = {
    permission: AccessLevel;
};

export type GrantVmPermissionRequest = {
    /**
     * List of allowed Linux users. If null, identity can SSH as any user.
     * If specified, identity can only SSH as users in this list.
     */
    allowedUsers?: Array<string> | null;
};

export type InternalServerError = string;

export type KillVmResponse = {
    id: VmShortId;
};

export type LinuxGroupSpec = {
    /**
     * Unique group name
     */
    name: string;
    /**
     * Optional fixed GID; if None, allocate
     */
    gid?: number | null;
    /**
     * System group (allocator uses system range)
     */
    system?: boolean | null;
};

export type LinuxUserSpec = {
    /**
     * Unique username
     */
    name: string;
    /**
     * Optional fixed UID; if None, allocate
     */
    uid?: number | null;
    /**
     * GECOS field (descriptive string, e.g., full name)
     */
    gecos?: string | null;
    /**
     * Groups to add user to (all groups use 'm' membership lines)
     */
    groups?: Array<string>;
    /**
     * Home directory path (optional, defaults to /home/{username} for regular users, / for system users)
     */
    home?: string | null;
    /**
     * Login shell (optional, defaults to /bin/bash for regular users, /usr/sbin/nologin for system users)
     */
    shell?: string | null;
    /**
     * System user (allocator uses system range)
     */
    system?: boolean | null;
};

export type ListGitPermissionSuccess = {
    repositories: Array<AccessibleRepository>;
};

export type ListGitTokensSuccess = {
    tokens: Array<AccessTokenInfo>;
};

export type ListIdentitiesSuccess = {
    identities: Array<FreestyleIdentity>;
    offset: number;
    total: number;
};

export type ListRecordsResponse = {
    records: Array<DnsRecord>;
};

export type ListRepositoriesSuccess = {
    repositories: Array<RepositoryMetadata>;
    total: number;
    offset: number;
};

export type ListSnapshotsResponse = {
    snapshots: Array<SnapshotInfo>;
};

export type ListVmPermissionsSuccess = {
    permissions: Array<VmPermission>;
    offset: number;
    total: number;
};

export type ListVmsResponse = {
    vms: Array<VmInfo>;
    totalCount: number;
    runningCount: number;
    startingCount: number;
    stoppedCount: number;
    userId?: string | null;
};

export type LogEntry = {
    line: string;
    timestamp?: string | null;
};

export type NetworkPermissionData = {
    query: string;
    behavior?: Behavior;
};

export type OptimizeVmResponse = {
    id: string;
    message: string;
};

export type PortConfig = {
    port: number;
    targetPort: number;
};

export type PortMapping = {
    port: number;
    targetPort: number;
};

export type ReadFileEphemeralDevServerResponses = {
    content: ReadFileResponseContent;
    exists: boolean;
    path: string;
};

export type ReadFileResponseContent = {
    content: string;
    kind: 'file';
} | {
    files: Array<string>;
    kind: 'directory';
};

export type RepositoryInfoRaw = {
    id: string;
    name?: string | null;
    accountId: string;
    visibility: Visibility;
    defaultBranch: string;
};

export type RepositoryMetadata = {
    branches: {
        [key: string]: BranchDetails;
    };
    tags: {
        [key: string]: TagDetails;
    };
    defaultBranch: string;
};

export type ResizeVmRequest = {
    rootfsSizeGb?: number | null;
    memSizeGb?: number | null;
    vcpuCount?: number | null;
};

export type ResizeVmResponse = {
    [key: string]: unknown;
};

export type RevokeGitTokenRequest = {
    tokenId: string;
};

export type SetDefaultBranchRequest = {
    defaultBranch: string;
};

export type SetDefaultBranchResponse = {
    [key: string]: unknown;
};

export type ShutdownDevServerRequest = {
    devServer: DevServerIdentifier;
};

export type Signature = {
    /**
     * The date marker for this signature
     */
    date: string;
    name: string;
    email: string;
};

export type SnapshotInfo = {
    /**
     * The ID of the snapshot
     */
    snapshotId: VmShortId;
    /**
     * The ID of the source VM
     */
    sourceVmId: VmShortId;
    /**
     * Account ID of the creator (if available)
     */
    accountId?: string | null;
    /**
     * When the snapshot was created
     */
    createdAt: string;
    /**
     * Optional name for the snapshot
     */
    name?: string | null;
    /**
     * Whether the snapshot has an overlay filesystem
     */
    hasOverlay: boolean;
    /**
     * The rootfs base ID if using overlayfs
     */
    rootfsBase?: string | null;
    /**
     * Partition ID where the snapshot is stored
     */
    partition?: string | null;
};

export type SnapshotVmRequest = {
    /**
     * Optional name/label for the snapshot
     */
    name?: string | null;
};

export type SnapshotVmResponse = {
    /**
     * The ID of the snapshot (same format as VM IDs)
     */
    snapshotId: VmShortId;
    /**
     * The ID of the source VM
     */
    sourceVmId: VmShortId;
};

export type StartVmRequest = {
    idleTimeoutSeconds?: number | null;
    readySignalTimeoutSeconds?: number | null;
    waitForReadySignal?: boolean | null;
};

export type StartedVmResponse = {
    id: string;
    domains: Array<string>;
    console_url?: string | null;
};

export type StopVmResponse = {
    id: VmShortId;
};

export type SuccessfullyDeletedDomainMapping = {
    [key: string]: unknown;
};

export type SuspendVmResponse = {
    id: string;
};

export type SystemdConfig = {
    services?: Array<SystemdUnitSpec> | null;
    patchedServices?: Array<SystemdUnitSpecPatch> | null;
};

export type SystemdConfigInternal = {
    enabled: boolean;
    services?: Array<SystemdUnitSpec> | null;
    patchedServices?: Array<SystemdUnitSpecPatch> | null;
};

export type SystemdRestartPolicy = {
    /**
     * "no" | "on-failure" | "always" | "on-abnormal"
     */
    policy: SystemdRestartPolicyKind;
    restartSec?: number | null;
    startLimitBurst?: number | null;
    startLimitIntervalSec?: number | null;
};

export type SystemdRestartPolicyKind = 'no' | 'on-failure' | 'always' | 'on-abnormal';

export type SystemdUnitMode = 'oneshot' | 'service';

export type SystemdUnitSpec = {
    /**
     * Unique slug; becomes unit name "<name>.service".
     */
    name: string;
    /**
     * "oneshot" (run and exit) or "service" (long-running/healing).
     */
    mode: SystemdUnitMode;
    /**
     * Executable to run (can specify multiple commands that run sequentially).
     */
    exec: Array<string>;
    /**
     * Environment variables.
     */
    env?: {
        [key: string]: string;
    } | null;
    /**
     * Linux user to run the service as.
     */
    user?: string | null;
    /**
     * Linux group to run the service in.
     */
    group?: string | null;
    /**
     * Working directory.
     */
    workdir?: string | null;
    /**
     * Establishes an ordering dependency. The current unit will start only
     * after the units listed in After= have started. This is useful for
     * ensuring that certain services are up and running before the current
     * service begins its operation.
     */
    after?: Array<string> | null;
    /**
     * Establishes a strong dependency. If the required unit fails to
     * start or stops unexpectedly, the current unit will also be stopped. This
     * ensures that a service critical to the functioning of the current unit
     * is running and stable. Units listed in Requires= are activated along
     * with the current unit. If the required unit is not active, systemd will
     * attempt to start it. This directive signifies a tight coupling between
     * services, where the current service cannot function without the required
     * service.
     */
    requires?: Array<string> | null;
    /**
     * Units to activate when this unit enters a failed state. This is useful
     * for triggering recovery actions, notifications, or cleanup services when
     * the current service fails.
     */
    onFailure?: Array<string> | null;
    /**
     * Target used when enabling (default: multi-user.target).
     */
    wantedBy?: Array<string> | null;
    /**
     * Whether to enable this service (calls `systemctl enable <service>`).
     * When enabled, the service will start automatically at boot.
     */
    enable?: boolean | null;
    /**
     * Overall start/stop timeout.
     */
    timeoutSec?: number | null;
    /**
     * For oneshot: remove unit on success.
     */
    deleteAfterSuccess?: boolean | null;
    /**
     * For oneshot: remain active after exit (default: true).
     * When false, the service can be started again even if it already ran.
     */
    remainAfterExit?: boolean | null;
    /**
     * Use sd_notify; maps to Type=notify.
     */
    readySignal?: boolean | null;
    /**
     * Enable systemd watchdog (seconds).
     */
    watchdogSec?: number | null;
    restartPolicy?: null | SystemdRestartPolicy;
};

export type SystemdUnitSpecPatch = {
    /**
     * Unique slug; becomes unit name "<name>.service".
     */
    name: string;
    mode?: null | SystemdUnitMode;
    /**
     * Executable to run (can specify multiple commands that run sequentially).
     */
    exec?: Array<string> | null;
    /**
     * Environment variables.
     */
    env?: {
        [key: string]: string;
    } | null;
    /**
     * Linux user to run the service as.
     */
    user?: string | null;
    /**
     * Linux group to run the service in.
     */
    group?: string | null;
    /**
     * Working directory.
     */
    workdir?: string | null;
    /**
     * Establishes an ordering dependency. The current unit will start only
     * after the units listed in After= have started. This is useful for
     * ensuring that certain services are up and running before the current
     * service begins its operation.
     */
    after?: Array<string> | null;
    /**
     * Establishes a strong dependency. If the required unit fails to
     * start or stops unexpectedly, the current unit will also be stopped. This
     * ensures that a service critical to the functioning of the current unit
     * is running and stable. Units listed in Requires= are activated along
     * with the current unit. If the required unit is not active, systemd will
     * attempt to start it. This directive signifies a tight coupling between
     * services, where the current service cannot function without the required
     * service.
     */
    requires?: Array<string> | null;
    /**
     * Units to activate when this unit enters a failed state. This is useful
     * for triggering recovery actions, notifications, or cleanup services when
     * the current service fails.
     */
    onFailure?: Array<string> | null;
    /**
     * Target used when enabling (default: multi-user.target).
     */
    wantedBy?: Array<string> | null;
    /**
     * Whether to enable this service (calls `systemctl enable <service>`).
     * When enabled, the service will start automatically at boot.
     */
    enable?: boolean | null;
    /**
     * Overall start/stop timeout.
     */
    timeoutSec?: number | null;
    /**
     * For oneshot: remove unit on success.
     */
    deleteAfterSuccess?: boolean | null;
    /**
     * Use sd_notify; maps to Type=notify.
     */
    readySignal?: boolean | null;
    /**
     * Enable systemd watchdog (seconds).
     */
    watchdogSec?: number | null;
    restartPolicy?: null | SystemdRestartPolicy;
};

export type TagDetails = {
    name: string;
    target: string;
    message?: string | null;
};

/**
 * Tag object
 */
export type TagObject = {
    /**
     * The tag name
     */
    name: string;
    tagger?: null | Signature;
    /**
     * The tag message
     */
    message?: string | null;
    /**
     * The object this tag points to
     */
    target: TagTarget;
    /**
     * The tag's hash ID
     */
    sha: string;
};

export type TagTarget = {
    /**
     * The target object's hash ID
     */
    sha: string;
};

export type TerminalListResponse = {
    terminals: Array<TerminalSession>;
};

export type TerminalLogsArrayResponse = {
    logs: Array<LogEntry>;
};

export type TerminalLogsResponse = {
    output: string;
};

export type TerminalSession = {
    name: string;
    status: string;
    created?: string | null;
};

export type TreeEntry = {
    path: string;
    sha: string;
    size: number;
    type: 'blob';
} | {
    path: string;
    sha: string;
    type: 'tree';
};

/**
 * Tree object
 */
export type TreeObject = {
    /**
     * The tree's entries
     */
    tree: Array<TreeEntry>;
    /**
     * The tree's hash ID
     */
    sha: string;
};

export type UpdateAllowedUsersRequestBody = {
    /**
     * List of allowed Linux users. If null, identity can SSH as any user.
     * If specified, identity can only SSH as users in this list.
     */
    allowedUsers?: Array<string> | null;
};

export type UpdateDevServerConfigRequest = DevServerConfiguration & {
    branch?: string | null;
};

export type UpdateGitPermissionRequest = {
    permission: AccessLevel;
};

export type VmState = 'starting' | 'running' | 'suspending' | 'stopped';

export type Visibility = 'public' | 'private';

export type VmDeleteEvent = 'OnStop' | 'OnSuspend';

export type VmInfo = {
    id: string;
    state: VmState;
    metrics?: null | VmMetricsInfo;
    createdAt?: string | null;
    lastNetworkActivity?: string | null;
    cpuTimeSeconds?: number | null;
};

export type VmMetricsInfo = {
    wallTimeSeconds: number;
    billingDay: string;
    isActiveToday: boolean;
};

/**
 * Full VM permission record
 */
export type VmPermission = {
    id: string;
    vmId: string;
    identityId: string;
    allowedUsers?: Array<string> | null;
    grantedAt: string;
    grantedBy: string;
};

export type VmPersistence = {
    /**
     * Priority for eviction when storage quota is reached. Higher values
     * mean the VM is less likely to be evicted. Range is 0-10, default is
     * 5.
     */
    priority?: number | null;
    type: 'sticky';
} | {
    deleteEvent?: null | VmDeleteEvent;
    type: 'ephemeral';
} | {
    type: 'persistent';
};

/**
 * Short VM ID (5-character alphanumeric) - used for filesystem operations
 */
export type VmShortId = string;

export type VmTemplate = {
    /**
     * Optional snapshot ID to create a VM from. If provided, the new VM will be
     * created from the specified snapshot. Cannot be used together with fork_vm_id or docker_image.
     */
    snapshotId?: string | null;
    rootfsSizeGb?: number | null;
    memSizeGb?: number | null;
    vcpuCount?: number | null;
    /**
     * Optional working directory for the VM. If not provided, the default to '/'
     */
    workdir?: string | null;
    /**
     * Idle timeout in seconds. If set, the VM will be automatically suspended
     * after this many seconds of no network activity. Defaults to 300 seconds
     * (5 minutes) if not provided or the last used timeout for the forked VM.
     */
    idleTimeoutSeconds?: number | null;
    waitForReadySignal?: boolean | null;
    readySignalTimeoutSeconds?: number | null;
    persistence?: null | VmPersistence;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000
     * will be exposed on port 443 by default. Pass an empty array to disable
     * external ports. Only ports 8081 and 443 can be configured externally for
     * now. Any target port is allowed.
     */
    ports?: Array<{
        port: number;
        targetPort: number;
    }> | null;
    systemd?: null | SystemdConfig;
    /**
     * Linux users to create on VM startup
     */
    users?: Array<LinuxUserSpec> | null;
    /**
     * Linux groups to create on VM startup
     */
    groups?: Array<LinuxGroupSpec> | null;
    additionalFiles?: {
        [key: string]: FreestyleFile;
    } | null;
    gitRepos?: Array<GitRepositorySpec> | null;
    /**
     * Optional discriminator to differentiate snapshots with otherwise identical configurations
     */
    discriminator?: string | null;
    /**
     * Optional list of apt packages to install when setting up the VM.
     * These packages will be installed using `apt-get install` on VM startup.
     */
    aptDeps?: Array<string> | null;
};

export type WaitVmResponse = {
    id: VmShortId;
    exitStatus: string;
};

export type WriteFileRequest = {
    content: string;
};

export type WriteFileResponse = {
    [key: string]: unknown;
};

export type HandleDeployCloudstateData = {
    body: FreestyleCloudstateDeployRequest;
    path?: never;
    query?: never;
    url: '/cloudstate/v1/deploy';
};

export type HandleDeployCloudstateErrors = {
    /**
     * failed to deploy
     */
    500: FreestyleCloudstateDeployErrorResponse;
};

export type HandleDeployCloudstateError = HandleDeployCloudstateErrors[keyof HandleDeployCloudstateErrors];

export type HandleDeployCloudstateResponses = {
    /**
     * successfully deployed
     */
    200: FreestyleCloudstateDeploySuccessResponse;
};

export type HandleDeployCloudstateResponse = HandleDeployCloudstateResponses[keyof HandleDeployCloudstateResponses];

export type HandleBackupCloudstateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/cloudstate/v1/projects/{id}/backup';
};

export type HandleBackupCloudstateErrors = {
    /**
     * failed to backup
     */
    500: unknown;
};

export type HandleBackupCloudstateResponses = {
    /**
     * successfully backed up
     */
    200: Array<number>;
};

export type HandleBackupCloudstateResponse = HandleBackupCloudstateResponses[keyof HandleBackupCloudstateResponses];

export type HandleDevServerRequestData = {
    body: DevServerRequestV2;
    path?: never;
    query?: never;
    url: '/dev-servers/v1/dev-servers/request';
};

export type HandleDeleteRecordData = {
    body?: never;
    path?: never;
    query: {
        domain: string;
        record: DnsRecord;
    };
    url: '/dns/v1/records';
};

export type HandleDeleteRecordErrors = {
    /**
     * Possible errors: DomainOwnershipError, RecordOwnershipError, DomainOwnershipVerificationFailed
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: ErrorCreatingRecord, ErrorDeletingRecord
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleDeleteRecordError = HandleDeleteRecordErrors[keyof HandleDeleteRecordErrors];

export type HandleDeleteRecordResponses = {
    200: DeleteRecordResponse;
};

export type HandleDeleteRecordResponse = HandleDeleteRecordResponses[keyof HandleDeleteRecordResponses];

export type HandleListRecordsData = {
    body?: never;
    path?: never;
    query: {
        domain: string;
    };
    url: '/dns/v1/records';
};

export type HandleListRecordsErrors = {
    400: {
        message: string;
    };
};

export type HandleListRecordsError = HandleListRecordsErrors[keyof HandleListRecordsErrors];

export type HandleListRecordsResponses = {
    200: ListRecordsResponse;
};

export type HandleListRecordsResponse = HandleListRecordsResponses[keyof HandleListRecordsResponses];

export type HandleCreateRecordData = {
    body: CreateRecordParams;
    path?: never;
    query?: never;
    url: '/dns/v1/records';
};

export type HandleCreateRecordErrors = {
    /**
     * Possible errors: DomainOwnershipError, RecordOwnershipError, DomainOwnershipVerificationFailed
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: ErrorCreatingRecord, ErrorDeletingRecord
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleCreateRecordError = HandleCreateRecordErrors[keyof HandleCreateRecordErrors];

export type HandleCreateRecordResponses = {
    200: CreateRecordResponse;
};

export type HandleCreateRecordResponse = HandleCreateRecordResponses[keyof HandleCreateRecordResponses];

export type HandleVerifyWildcardData = {
    body?: never;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/certs/{domain}/wildcard';
};

export type HandleVerifyWildcardErrors = {
    /**
     * Failed to preverify domain
     */
    400: {
        message: string;
    };
};

export type HandleVerifyWildcardError = HandleVerifyWildcardErrors[keyof HandleVerifyWildcardErrors];

export type HandleVerifyWildcardResponses = {
    /**
     * Domain verified
     */
    200: {
        domain: string;
    };
};

export type HandleVerifyWildcardResponse = HandleVerifyWildcardResponses[keyof HandleVerifyWildcardResponses];

export type HandleListDomainsData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
        implicitlyOwned?: boolean | null;
    };
    url: '/domains/v1/domains';
};

export type HandleListDomainsErrors = {
    /**
     * Failed to get domains
     */
    400: {
        message: string;
    };
};

export type HandleListDomainsError = HandleListDomainsErrors[keyof HandleListDomainsErrors];

export type HandleListDomainsResponses = {
    /**
     * List of domains
     */
    200: Array<{
        domain: string;
        accountId: string;
        createdAt: string;
        id: string;
        verifiedDns: boolean;
        implicitlyOwned: boolean;
        deployToDomain: boolean;
        manageDns: boolean;
        deployToSubdomains: boolean;
    }>;
};

export type HandleListDomainsResponse = HandleListDomainsResponses[keyof HandleListDomainsResponses];

export type HandleListDomainMappingsData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number | null;
        limit?: number | null;
        domainOwnership?: string | null;
        domain?: string | null;
    };
    url: '/domains/v1/mappings';
};

export type HandleListDomainMappingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type HandleListDomainMappingsResponses = {
    /**
     * List of domain mappings
     */
    200: Array<FreestyleSandboxDomainMapping>;
};

export type HandleListDomainMappingsResponse = HandleListDomainMappingsResponses[keyof HandleListDomainMappingsResponses];

export type HandleDeleteDomainMappingData = {
    body?: never;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/mappings/{domain}';
};

export type HandleDeleteDomainMappingErrors = {
    /**
     * Error: DomainAlreadyExists
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: FailedPermissionsCheck
     */
    401: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: FailedRemoveDomainMapping, FailedToInsertOwnership
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: FailedToCheckDomainMappingPermissions
     */
    502: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleDeleteDomainMappingError = HandleDeleteDomainMappingErrors[keyof HandleDeleteDomainMappingErrors];

export type HandleDeleteDomainMappingResponses = {
    /**
     * Successfully deleted domain mapping
     */
    200: SuccessfullyDeletedDomainMapping;
};

export type HandleDeleteDomainMappingResponse = HandleDeleteDomainMappingResponses[keyof HandleDeleteDomainMappingResponses];

export type HandleInsertDomainMappingData = {
    body: CreateDomainMappingRequest;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/mappings/{domain}';
};

export type HandleInsertDomainMappingErrors = {
    /**
     * You do not have permission to do this
     */
    401: {
        message: string;
    };
    /**
     * Failed to provision certificate
     */
    422: {
        message: string;
    };
    /**
     * Failed to insert ownership
     */
    500: {
        message: string;
    };
    /**
     * Failed to check permissions
     */
    502: {
        message: string;
    };
};

export type HandleInsertDomainMappingError = HandleInsertDomainMappingErrors[keyof HandleInsertDomainMappingErrors];

export type HandleInsertDomainMappingResponses = {
    /**
     * Successfully mapped domain to deployment
     */
    200: FreestyleSandboxDomainMapping;
};

export type HandleInsertDomainMappingResponse = HandleInsertDomainMappingResponses[keyof HandleInsertDomainMappingResponses];

export type HandleDeleteDomainVerificationData = {
    body: FreestyleDeleteDomainVerificationRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleDeleteDomainVerificationErrors = {
    /**
     * Failed to create verification code
     */
    400: {
        message: string;
    };
};

export type HandleDeleteDomainVerificationError = HandleDeleteDomainVerificationErrors[keyof HandleDeleteDomainVerificationErrors];

export type HandleDeleteDomainVerificationResponses = {
    /**
     * Verification code created
     */
    200: {
        verificationCode: string;
        domain: string;
    };
};

export type HandleDeleteDomainVerificationResponse = HandleDeleteDomainVerificationResponses[keyof HandleDeleteDomainVerificationResponses];

export type HandleListDomainVerificationRequestsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleListDomainVerificationRequestsErrors = {
    /**
     * Failed to get verification codes
     */
    400: {
        message: string;
    };
};

export type HandleListDomainVerificationRequestsError = HandleListDomainVerificationRequestsErrors[keyof HandleListDomainVerificationRequestsErrors];

export type HandleListDomainVerificationRequestsResponses = {
    /**
     * List of verification codes
     */
    200: Array<{
        verificationCode: string;
        domain: string;
        createdAt: string;
    }>;
};

export type HandleListDomainVerificationRequestsResponse = HandleListDomainVerificationRequestsResponses[keyof HandleListDomainVerificationRequestsResponses];

export type HandleCreateDomainVerificationData = {
    body: FreestyleDomainVerificationRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleCreateDomainVerificationErrors = {
    /**
     * Failed to create verification code
     */
    400: {
        message: string;
    };
};

export type HandleCreateDomainVerificationError = HandleCreateDomainVerificationErrors[keyof HandleCreateDomainVerificationErrors];

export type HandleCreateDomainVerificationResponses = {
    /**
     * Verification code created
     */
    200: DomainVerificationRequest;
};

export type HandleCreateDomainVerificationResponse = HandleCreateDomainVerificationResponses[keyof HandleCreateDomainVerificationResponses];

export type HandleVerifyDomainData = {
    body: FreestyleVerifyDomainRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleVerifyDomainErrors = {
    /**
     * Failed to verify domain
     */
    400: {
        message: string;
    };
    /**
     * Domain verification request not found
     */
    404: {
        message: string;
    };
};

export type HandleVerifyDomainError = HandleVerifyDomainErrors[keyof HandleVerifyDomainErrors];

export type HandleVerifyDomainResponses = {
    /**
     * Domain verified
     */
    200: {
        domain: string;
    };
};

export type HandleVerifyDomainResponse = HandleVerifyDomainResponses[keyof HandleVerifyDomainResponses];

export type HandleEphemeralDevServerData = {
    body: DevServerRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers';
};

export type HandleEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        /**
         * @deprecated
         */
        url: string;
        isNew: boolean;
        devCommandRunning: boolean;
        installCommandRunning: boolean;
        mcpEphemeralUrl?: string | null;
        ephemeralUrl?: string | null;
        vmId?: string | null;
        baseId?: string | null;
    };
};

export type HandleEphemeralDevServerResponse = HandleEphemeralDevServerResponses[keyof HandleEphemeralDevServerResponses];

export type HandleExecOnEphemeralDevServerData = {
    body: ExecRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/exec';
};

export type HandleExecOnEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        id: string;
        isNew: boolean;
        stdout?: Array<string> | null;
        stderr?: Array<string> | null;
    };
};

export type HandleExecOnEphemeralDevServerResponse = HandleExecOnEphemeralDevServerResponses[keyof HandleExecOnEphemeralDevServerResponses];

export type HandleGitCommitPushData = {
    body: GitCommitPushRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/git/commit-push';
};

export type HandleGitCommitPushErrors = {
    /**
     * Error: DevServerInvalidRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: DevServerNotFound, DevServerFileNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: RequestFailed, ExecutionFailed, ReadFileFailed, WriteFileFailed, CommitFailed, ShutdownFailed, RestartFailed, StatusFailed, LogsFailed, InternalError, WatchFilesFailed, BrowserOperationFailed
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleGitCommitPushError = HandleGitCommitPushErrors[keyof HandleGitCommitPushErrors];

export type HandleGitCommitPushResponses = {
    200: GitCommitPushResponse;
};

export type HandleGitCommitPushResponse = HandleGitCommitPushResponses[keyof HandleGitCommitPushResponses];

export type HandleDevServerLogsData = {
    body: DevServerLogsRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/logs';
};

export type HandleDevServerLogsResponses = {
    /**
     * Successful
     */
    200: {
        logs: string;
    };
};

export type HandleDevServerLogsResponse = HandleDevServerLogsResponses[keyof HandleDevServerLogsResponses];

export type HandleDevServerRestartData = {
    body: DevServerRestartRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/restart';
};

export type HandleDevServerRestartResponses = {
    /**
     * Successful
     */
    200: {
        restarted: boolean;
    };
};

export type HandleDevServerRestartResponse = HandleDevServerRestartResponses[keyof HandleDevServerRestartResponses];

export type HandleShutdownDevServerData = {
    body: ShutdownDevServerRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/shutdown';
};

export type HandleShutdownDevServerResponses = {
    /**
     * Successful
     */
    200: {
        shutdown: boolean;
    };
};

export type HandleShutdownDevServerResponse = HandleShutdownDevServerResponses[keyof HandleShutdownDevServerResponses];

export type HandleDevServerStatusData = {
    body: DevServerStatusRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/status';
};

export type HandleDevServerStatusResponses = {
    /**
     * Successful
     */
    200: {
        installing: boolean;
        devRunning: boolean;
    };
};

export type HandleDevServerStatusResponse = HandleDevServerStatusResponses[keyof HandleDevServerStatusResponses];

export type HandleWatchDevServerFilesData = {
    body: DevServerWatchFilesRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/watch-files';
};

export type HandleWatchDevServerFilesResponses = {
    /**
     * Stream of file events
     */
    200: string;
};

export type HandleWatchDevServerFilesResponse = HandleWatchDevServerFilesResponses[keyof HandleWatchDevServerFilesResponses];

export type HandleListExecuteRunsData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
    };
    url: '/execute/v1/deployments';
};

export type HandleListExecuteRunsErrors = {
    500: {
        message: string;
    };
};

export type HandleListExecuteRunsError = HandleListExecuteRunsErrors[keyof HandleListExecuteRunsErrors];

export type HandleListExecuteRunsResponses = {
    200: {
        entries: Array<ExecuteLogEntry>;
        total: number;
        offset: number;
    };
};

export type HandleListExecuteRunsResponse = HandleListExecuteRunsResponses[keyof HandleListExecuteRunsResponses];

export type HandleGetExecuteRunData = {
    body?: never;
    path: {
        deployment: string;
    };
    query?: never;
    url: '/execute/v1/deployments/{deployment}';
};

export type HandleGetExecuteRunErrors = {
    /**
     * Unauthorized access
     */
    401: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetExecuteRunError = HandleGetExecuteRunErrors[keyof HandleGetExecuteRunErrors];

export type HandleGetExecuteRunResponses = {
    /**
     * Success
     */
    200: {
        metadata: ExecuteLogEntry;
        code?: null | ExecuteRunInfo;
    };
};

export type HandleGetExecuteRunResponse = HandleGetExecuteRunResponses[keyof HandleGetExecuteRunResponses];

export type HandleExecuteScriptData = {
    body: FreestyleExecuteScriptParams;
    path?: never;
    query?: never;
    url: '/execute/v1/script';
};

export type HandleExecuteScriptErrors = {
    /**
     * Error
     */
    400: {
        error: string;
        logs?: Array<FreestyleJavaScriptLog> | null;
    };
    /**
     * Internal server error
     */
    500: {
        error: string;
        logs?: Array<FreestyleJavaScriptLog> | null;
    };
};

export type HandleExecuteScriptError = HandleExecuteScriptErrors[keyof HandleExecuteScriptErrors];

export type HandleExecuteScriptResponses = {
    /**
     * Success
     */
    200: {
        /**
         * The return value of the default export of the script
         */
        result: unknown;
        logs: Array<FreestyleJavaScriptLog>;
    };
};

export type HandleExecuteScriptResponse = HandleExecuteScriptResponses[keyof HandleExecuteScriptResponses];

export type HandleListIdentitiesData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
        includeManaged?: boolean | null;
    };
    url: '/git/v1/identity';
};

export type HandleListIdentitiesResponses = {
    /**
     * List of identities
     */
    200: ListIdentitiesSuccess;
};

export type HandleListIdentitiesResponse = HandleListIdentitiesResponses[keyof HandleListIdentitiesResponses];

export type HandleCreateIdentityData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/git/v1/identity';
};

export type HandleCreateIdentityResponses = {
    /**
     * Identity created successfully
     */
    200: FreestyleIdentity;
};

export type HandleCreateIdentityResponse = HandleCreateIdentityResponses[keyof HandleCreateIdentityResponses];

export type HandleDeleteIdentityData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}';
};

export type HandleDeleteIdentityErrors = {
    /**
     * Access denied
     */
    403: ErrorResponse;
    /**
     * Identity not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type HandleDeleteIdentityError = HandleDeleteIdentityErrors[keyof HandleDeleteIdentityErrors];

export type HandleDeleteIdentityResponses = {
    /**
     * Identity deleted
     */
    200: EmptyResponse;
};

export type HandleDeleteIdentityResponse = HandleDeleteIdentityResponses[keyof HandleDeleteIdentityResponses];

export type HandleListPermissionsData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
    url: '/git/v1/identity/{identity}/permissions';
};

export type HandleListPermissionsErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
};

export type HandleListPermissionsError = HandleListPermissionsErrors[keyof HandleListPermissionsErrors];

export type HandleListPermissionsResponses = {
    /**
     * Permission list
     */
    200: ListGitPermissionSuccess;
};

export type HandleListPermissionsResponse = HandleListPermissionsResponses[keyof HandleListPermissionsResponses];

export type HandleRevokePermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleRevokePermissionErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
};

export type HandleRevokePermissionError = HandleRevokePermissionErrors[keyof HandleRevokePermissionErrors];

export type HandleRevokePermissionResponses = {
    /**
     * Permission revoked successfully
     */
    200: EmptyResponse;
};

export type HandleRevokePermissionResponse = HandleRevokePermissionResponses[keyof HandleRevokePermissionResponses];

export type HandleDescribePermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleDescribePermissionErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
};

export type HandleDescribePermissionError = HandleDescribePermissionErrors[keyof HandleDescribePermissionErrors];

export type HandleDescribePermissionResponses = {
    /**
     * Permission info
     */
    200: DescribeGitPermissionSuccess;
};

export type HandleDescribePermissionResponse = HandleDescribePermissionResponses[keyof HandleDescribePermissionResponses];

export type HandleUpdatePermissionData = {
    body: UpdateGitPermissionRequest;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleGrantPermissionData = {
    body: GrantGitPermissionRequest;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleGrantPermissionErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Not Found
     */
    404: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
};

export type HandleGrantPermissionError = HandleGrantPermissionErrors[keyof HandleGrantPermissionErrors];

export type HandleGrantPermissionResponses = {
    /**
     * Permission granted successfully
     */
    200: EmptyResponse;
};

export type HandleGrantPermissionResponse = HandleGrantPermissionResponses[keyof HandleGrantPermissionResponses];

export type HandleRevokeGitTokenData = {
    body: RevokeGitTokenRequest;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleRevokeGitTokenErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Identity not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type HandleRevokeGitTokenError = HandleRevokeGitTokenErrors[keyof HandleRevokeGitTokenErrors];

export type HandleRevokeGitTokenResponses = {
    /**
     * Token revoked
     */
    200: EmptyResponse;
};

export type HandleRevokeGitTokenResponse = HandleRevokeGitTokenResponses[keyof HandleRevokeGitTokenResponses];

export type HandleListGitTokensData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleListGitTokensErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Identity not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type HandleListGitTokensError = HandleListGitTokensErrors[keyof HandleListGitTokensErrors];

export type HandleListGitTokensResponses = {
    /**
     * Token list
     */
    200: ListGitTokensSuccess;
};

export type HandleListGitTokensResponse = HandleListGitTokensResponses[keyof HandleListGitTokensResponses];

export type HandleCreateGitTokenData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleCreateGitTokenErrors = {
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Identity not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type HandleCreateGitTokenError = HandleCreateGitTokenErrors[keyof HandleCreateGitTokenErrors];

export type HandleCreateGitTokenResponses = {
    /**
     * Token created successfully
     */
    200: CreatedToken;
};

export type HandleCreateGitTokenResponse = HandleCreateGitTokenResponses[keyof HandleCreateGitTokenResponses];

export type HandleListRepositoriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
    url: '/git/v1/repo';
};

export type HandleListRepositoriesErrors = {
    /**
     * Error: Internal
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleListRepositoriesError = HandleListRepositoriesErrors[keyof HandleListRepositoriesErrors];

export type HandleListRepositoriesResponses = {
    /**
     * List of repositories
     */
    200: ListRepositoriesSuccess;
};

export type HandleListRepositoriesResponse = HandleListRepositoriesResponses[keyof HandleListRepositoriesResponses];

export type HandleCreateRepoData = {
    body: {
        /**
         * This name is not visible to users, and is only accessible to you via API and in the
         * dashboard. Mostly useful for observability.
         */
        name?: string | null;
        public?: boolean;
        /**
         * The default branch name for the repository. Defaults to "main" if not specified.
         */
        defaultBranch?: string | null;
        /**
         * Fork from another Git repository. Cannot be used with `import`.
         */
        source?: CreateRepoSource;
        /**
         * Import static content with an initial commit. Cannot be used with `source`.
         */
        import?: CreateRepoImport;
        devServers?: DevServerConfiguration;
    };
    path?: never;
    query?: never;
    url: '/git/v1/repo';
};

export type HandleCreateRepoErrors = {
    /**
     * Error: InternalServerError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleCreateRepoError = HandleCreateRepoErrors[keyof HandleCreateRepoErrors];

export type HandleCreateRepoResponses = {
    /**
     * Repository created successfully
     */
    200: CreateRepositoryResponseSuccess;
};

export type HandleCreateRepoResponse = HandleCreateRepoResponses[keyof HandleCreateRepoResponses];

export type HandleGetDefaultBranchData = {
    body?: never;
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/default-branch';
};

export type HandleGetDefaultBranchErrors = {
    /**
     * Error: Forbidden
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: RepoNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: Internal
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleGetDefaultBranchError = HandleGetDefaultBranchErrors[keyof HandleGetDefaultBranchErrors];

export type HandleGetDefaultBranchResponses = {
    /**
     * Success
     */
    200: GetDefaultBranchResponse;
};

export type HandleGetDefaultBranchResponse = HandleGetDefaultBranchResponses[keyof HandleGetDefaultBranchResponses];

export type HandleSetDefaultBranchData = {
    body: SetDefaultBranchRequest;
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/default-branch';
};

export type HandleSetDefaultBranchErrors = {
    /**
     * Error: Forbidden
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: RepoNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: Internal
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleSetDefaultBranchError = HandleSetDefaultBranchErrors[keyof HandleSetDefaultBranchErrors];

export type HandleSetDefaultBranchResponses = {
    /**
     * Success
     */
    200: SetDefaultBranchResponse;
};

export type HandleSetDefaultBranchResponse = HandleSetDefaultBranchResponses[keyof HandleSetDefaultBranchResponses];

export type DeleteDevServerConfigurationData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query: {
        /**
         * Git branch name (optional, defaults to repository default branch)
         */
        branch: string;
    };
    url: '/git/v1/repo/{repo_id}/dev-server-configuration';
};

export type DeleteDevServerConfigurationErrors = {
    /**
     * Repository or configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteDevServerConfigurationResponses = {
    /**
     * Dev server configuration deleted successfully
     */
    204: void;
};

export type DeleteDevServerConfigurationResponse = DeleteDevServerConfigurationResponses[keyof DeleteDevServerConfigurationResponses];

export type GetDevServerConfigurationData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query: {
        /**
         * Git branch name
         */
        branch: string;
    };
    url: '/git/v1/repo/{repo_id}/dev-server-configuration';
};

export type GetDevServerConfigurationErrors = {
    /**
     * Repository or configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetDevServerConfigurationResponses = {
    /**
     * Dev server configuration
     */
    200: DevServerConfiguration;
};

export type GetDevServerConfigurationResponse = GetDevServerConfigurationResponses[keyof GetDevServerConfigurationResponses];

export type UpdateDevServerConfigurationData = {
    body: UpdateDevServerConfigRequest;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/dev-server-configuration';
};

export type UpdateDevServerConfigurationErrors = {
    /**
     * Repository not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateDevServerConfigurationResponses = {
    /**
     * Dev server configuration updated successfully
     */
    200: unknown;
};

export type RemoveGithubSyncData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type RemoveGithubSyncErrors = {
    /**
     * Repository or sync configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveGithubSyncResponses = {
    /**
     * GitHub sync configuration removed successfully
     */
    200: unknown;
};

export type GetGithubSyncData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type GetGithubSyncErrors = {
    /**
     * Repository or sync configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetGithubSyncResponses = {
    /**
     * GitHub sync configuration
     */
    200: GithubSyncConfigResponse;
};

export type GetGithubSyncResponse = GetGithubSyncResponses[keyof GetGithubSyncResponses];

export type ConfigureGithubSyncData = {
    body: ConfigureGithubSyncRequest;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type ConfigureGithubSyncErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Repository not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ConfigureGithubSyncResponses = {
    /**
     * GitHub sync configured successfully
     */
    200: unknown;
};

export type HandleDeleteRepoData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}';
};

export type HandleDeleteRepoErrors = {
    /**
     * Error: Forbidden
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: RepoNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: Internal
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleDeleteRepoError = HandleDeleteRepoErrors[keyof HandleDeleteRepoErrors];

export type HandleDeleteRepoResponses = {
    /**
     * Repository deleted successfully
     */
    200: DeleteRepositorySuccess;
};

export type HandleDeleteRepoResponse = HandleDeleteRepoResponses[keyof HandleDeleteRepoResponses];

export type HandleGetRepoInfoData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}';
};

export type HandleGetRepoInfoErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Forbidden access to repository
     */
    403: unknown;
    /**
     * Repository not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type HandleGetRepoInfoResponses = {
    /**
     * Repository information retrieved successfully
     */
    200: RepositoryInfoRaw;
};

export type HandleGetRepoInfoResponse = HandleGetRepoInfoResponses[keyof HandleGetRepoInfoResponses];

export type HandleCompareCommitsData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query: {
        /**
         * Base revision (commit SHA, branch name, tag, or any valid Git revision)
         */
        base: string;
        /**
         * Head revision (commit SHA, branch name, tag, or any valid Git revision)
         */
        head: string;
    };
    url: '/git/v1/repo/{repo}/compare';
};

export type HandleCompareCommitsResponses = {
    /**
     * Comparison retrieved successfully
     */
    200: CommitComparison;
};

export type HandleCompareCommitsResponse = HandleCompareCommitsResponses[keyof HandleCompareCommitsResponses];

export type HandleGetContentsData = {
    body?: never;
    path: {
        /**
         * The repository ID.
         */
        repo: string;
        /**
         * The path to the file or directory. Empty for root.
         */
        path: string | null;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/contents/{path}';
};

export type HandleGetContentsResponses = {
    /**
     * Success
     */
    200: GitContents;
};

export type HandleGetContentsResponse = HandleGetContentsResponses[keyof HandleGetContentsResponses];

export type HandleGetBlobData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/blobs/{hash}';
};

export type HandleGetBlobResponses = {
    /**
     * Blob retrieved successfully
     */
    200: BlobObject;
};

export type HandleGetBlobResponse = HandleGetBlobResponses[keyof HandleGetBlobResponses];

export type HandleListCommitsData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * Branch name (defaults to HEAD)
         */
        branch?: string | null;
        /**
         * Maximum number of commits to return (default: 50, max: 500)
         */
        limit?: number | null;
        /**
         * Number of commits to skip (default: 0)
         */
        offset?: number | null;
    };
    url: '/git/v1/repo/{repo}/git/commits';
};

export type HandleListCommitsResponses = {
    /**
     * Commits retrieved successfully
     */
    200: CommitList;
};

export type HandleListCommitsResponse = HandleListCommitsResponses[keyof HandleListCommitsResponses];

export type HandleGetCommitData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/commits/{hash}';
};

export type HandleGetCommitResponses = {
    /**
     * Commit retrieved successfully
     */
    200: CommitObject;
};

export type HandleGetCommitResponse = HandleGetCommitResponses[keyof HandleGetCommitResponses];

export type HandleGetRefBranchData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The branch's name
         */
        branch: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/refs/heads/{branch}';
};

export type HandleGetRefBranchResponses = {
    /**
     * Branch reference retrieved successfully
     */
    200: GitReference;
};

export type HandleGetRefBranchResponse = HandleGetRefBranchResponses[keyof HandleGetRefBranchResponses];

export type HandleGetRefTagData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The tag's name
         */
        tag: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/refs/tags/{tag}';
};

export type HandleGetRefTagResponses = {
    /**
     * Tag reference retrieved successfully
     */
    200: GitReference;
};

export type HandleGetRefTagResponse = HandleGetRefTagResponses[keyof HandleGetRefTagResponses];

export type HandleGetTagData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/tags/{hash}';
};

export type HandleGetTagResponses = {
    /**
     * Tag retrieved successfully
     */
    200: TagObject;
};

export type HandleGetTagResponse = HandleGetTagResponses[keyof HandleGetTagResponses];

export type HandleGetTreeData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/trees/{hash}';
};

export type HandleGetTreeResponses = {
    /**
     * Tree retrieved successfully
     */
    200: TreeObject;
};

export type HandleGetTreeResponse = HandleGetTreeResponses[keyof HandleGetTreeResponses];

export type HandleDownloadTarballData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/tarball';
};

export type HandleDownloadTarballResponses = {
    /**
     * Success (byte stream)
     */
    200: Blob | File;
};

export type HandleDownloadTarballResponse = HandleDownloadTarballResponses[keyof HandleDownloadTarballResponses];

export type HandleListGitTriggersData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger';
};

export type HandleListGitTriggersErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to access this repository
     */
    403: {
        message: string;
    };
    /**
     * Repository does not exist
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListGitTriggersError = HandleListGitTriggersErrors[keyof HandleListGitTriggersErrors];

export type HandleListGitTriggersResponses = {
    /**
     * Success
     */
    200: {
        triggers: Array<GitRepositoryTrigger>;
    };
};

export type HandleListGitTriggersResponse = HandleListGitTriggersResponses[keyof HandleListGitTriggersResponses];

export type HandleCreateGitTriggerData = {
    body: {
        trigger: {
            branches?: Array<string> | null;
            globs?: Array<string> | null;
            event: 'push';
        };
        action: {
            endpoint: string;
            action: 'webhook';
        };
    };
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger';
};

export type HandleCreateGitTriggerErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to create a trigger on this repository
     */
    403: {
        message: string;
    };
    /**
     * Repository does not exist
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleCreateGitTriggerError = HandleCreateGitTriggerErrors[keyof HandleCreateGitTriggerErrors];

export type HandleCreateGitTriggerResponses = {
    /**
     * Trigger created successfully
     */
    200: {
        triggerId: string;
    };
};

export type HandleCreateGitTriggerResponse = HandleCreateGitTriggerResponses[keyof HandleCreateGitTriggerResponses];

export type HandleDeleteGitTriggerData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The trigger id
         */
        trigger: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger/{trigger}';
};

export type HandleDeleteGitTriggerErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to delete a trigger on this repository
     */
    403: {
        message: string;
    };
    /**
     * Trigger does not exist
     */
    404: {
        [key: string]: unknown;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleDeleteGitTriggerError = HandleDeleteGitTriggerErrors[keyof HandleDeleteGitTriggerErrors];

export type HandleDeleteGitTriggerResponses = {
    /**
     * Trigger deleted successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleDeleteGitTriggerResponse = HandleDeleteGitTriggerResponses[keyof HandleDeleteGitTriggerResponses];

export type HandleDownloadZipData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/zip';
};

export type HandleDownloadZipResponses = {
    /**
     * Success (byte stream)
     */
    200: Blob | File;
};

export type HandleDownloadZipResponse = HandleDownloadZipResponses[keyof HandleDownloadZipResponses];

export type HandleListIdentities2Data = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
        includeManaged?: boolean | null;
    };
    url: '/identity/v1/identities';
};

export type HandleListIdentities2Responses = {
    /**
     * List of identities
     */
    200: ListIdentitiesSuccess;
};

export type HandleListIdentities2Response = HandleListIdentities2Responses[keyof HandleListIdentities2Responses];

export type HandleCreateIdentity2Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/identity/v1/identities';
};

export type HandleCreateIdentity2Responses = {
    /**
     * Identity created successfully
     */
    200: FreestyleIdentity;
};

export type HandleCreateIdentity2Response = HandleCreateIdentity2Responses[keyof HandleCreateIdentity2Responses];

export type HandleDeleteIdentity2Data = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}';
};

export type HandleDeleteIdentity2Responses = {
    /**
     * Identity deleted
     */
    200: EmptyResponse;
};

export type HandleDeleteIdentity2Response = HandleDeleteIdentity2Responses[keyof HandleDeleteIdentity2Responses];

export type HandleListGitPermissionsData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
    url: '/identity/v1/identities/{identity}/permissions/git';
};

export type HandleListGitPermissionsResponses = {
    /**
     * Permission list
     */
    200: ListGitPermissionSuccess;
};

export type HandleListGitPermissionsResponse = HandleListGitPermissionsResponses[keyof HandleListGitPermissionsResponses];

export type HandleRevokeGitPermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/git/{repo}';
};

export type HandleRevokeGitPermissionResponses = {
    /**
     * Permission revoked successfully
     */
    200: EmptyResponse;
};

export type HandleRevokeGitPermissionResponse = HandleRevokeGitPermissionResponses[keyof HandleRevokeGitPermissionResponses];

export type HandleDescribeGitPermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/git/{repo}';
};

export type HandleDescribeGitPermissionResponses = {
    /**
     * Permission info
     */
    200: DescribeGitPermissionSuccess;
};

export type HandleDescribeGitPermissionResponse = HandleDescribeGitPermissionResponses[keyof HandleDescribeGitPermissionResponses];

export type HandleGrantGitPermissionData = {
    body: GrantGitPermissionRequest;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/git/{repo}';
};

export type HandleGrantGitPermissionResponses = {
    /**
     * Permission granted successfully
     */
    200: EmptyResponse;
};

export type HandleGrantGitPermissionResponse = HandleGrantGitPermissionResponses[keyof HandleGrantGitPermissionResponses];

export type HandleUpdateGitPermissionData = {
    body: UpdateGitPermissionRequest;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The git repository ID
         */
        repo: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/git/{repo}';
};

export type HandleUpdateGitPermissionResponses = {
    /**
     * Permission updated successfully
     */
    200: EmptyResponse;
};

export type HandleUpdateGitPermissionResponse = HandleUpdateGitPermissionResponses[keyof HandleUpdateGitPermissionResponses];

export type HandleListVmPermissionsData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: {
        limit?: number | null;
        offset?: number | null;
    };
    url: '/identity/v1/identities/{identity}/permissions/vm';
};

export type HandleListVmPermissionsResponses = {
    /**
     * List of VM permissions
     */
    200: ListVmPermissionsSuccess;
};

export type HandleListVmPermissionsResponse = HandleListVmPermissionsResponses[keyof HandleListVmPermissionsResponses];

export type HandleRevokeVmPermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The VM ID
         */
        vm_id: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/vm/{vm_id}';
};

export type HandleRevokeVmPermissionResponses = {
    /**
     * VM permission revoked successfully
     */
    200: EmptyResponse;
};

export type HandleRevokeVmPermissionResponse = HandleRevokeVmPermissionResponses[keyof HandleRevokeVmPermissionResponses];

export type HandleDescribeVmPermissionData = {
    body?: never;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The VM ID
         */
        vm_id: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/vm/{vm_id}';
};

export type HandleDescribeVmPermissionResponses = {
    /**
     * VM permission details
     */
    200: VmPermission;
};

export type HandleDescribeVmPermissionResponse = HandleDescribeVmPermissionResponses[keyof HandleDescribeVmPermissionResponses];

export type HandleGrantVmPermissionData = {
    body: GrantVmPermissionRequest;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The VM ID
         */
        vm_id: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/vm/{vm_id}';
};

export type HandleGrantVmPermissionResponses = {
    /**
     * VM permission granted successfully
     */
    200: VmPermission;
};

export type HandleGrantVmPermissionResponse = HandleGrantVmPermissionResponses[keyof HandleGrantVmPermissionResponses];

export type HandleUpdateAllowedUsersData = {
    body: UpdateAllowedUsersRequestBody;
    path: {
        /**
         * The git identity ID
         */
        identity: string;
        /**
         * The VM ID
         */
        vm_id: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/permissions/vm/{vm_id}';
};

export type HandleUpdateAllowedUsersResponses = {
    /**
     * Allowed users updated successfully
     */
    200: VmPermission;
};

export type HandleUpdateAllowedUsersResponse = HandleUpdateAllowedUsersResponses[keyof HandleUpdateAllowedUsersResponses];

export type HandleListGitTokens2Data = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/tokens';
};

export type HandleListGitTokens2Responses = {
    /**
     * Token list
     */
    200: ListGitTokensSuccess;
};

export type HandleListGitTokens2Response = HandleListGitTokens2Responses[keyof HandleListGitTokens2Responses];

export type HandleCreateGitToken2Data = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/tokens';
};

export type HandleCreateGitToken2Responses = {
    /**
     * Token created successfully
     */
    200: CreatedToken;
};

export type HandleCreateGitToken2Response = HandleCreateGitToken2Responses[keyof HandleCreateGitToken2Responses];

export type HandleRevokeGitToken2Data = {
    body?: never;
    path: {
        identity: string;
        token: string;
    };
    query?: never;
    url: '/identity/v1/identities/{identity}/tokens/{token}';
};

export type HandleRevokeGitToken2Responses = {
    /**
     * Token revoked
     */
    200: EmptyResponse;
};

export type HandleRevokeGitToken2Response = HandleRevokeGitToken2Responses[keyof HandleRevokeGitToken2Responses];

export type HandleGetLogsData = {
    body?: never;
    path?: never;
    query?: {
        deploymentId?: string | null;
        domain?: string | null;
        pageToken?: string | null;
        pageSize?: number | null;
        /**
         * Start time in RFC3339 format (e.g., "2024-01-01T00:00:00Z"). Defaults to 24 hours ago if not specified.
         */
        startTime?: string | null;
        /**
         * End time in RFC3339 format (e.g., "2024-01-02T00:00:00Z"). Defaults to now if not specified.
         */
        endTime?: string | null;
    };
    url: '/observability/v1/logs';
};

export type HandleGetLogsResponses = {
    200: FreestyleGetLogsResponse;
};

export type HandleGetLogsResponse = HandleGetLogsResponses[keyof HandleGetLogsResponses];

export type ListVmsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/vms';
};

export type ListVmsErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ListVmsError = ListVmsErrors[keyof ListVmsErrors];

export type ListVmsResponses = {
    200: ListVmsResponse;
};

export type ListVmsResponse2 = ListVmsResponses[keyof ListVmsResponses];

export type CreateVmData = {
    body: CreateVmRequest;
    path?: never;
    query?: never;
    url: '/v1/vms';
};

export type CreateVmErrors = {
    /**
     * Error: CreateVmBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: ForkVmNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type CreateVmError = CreateVmErrors[keyof CreateVmErrors];

export type CreateVmResponses = {
    200: CreateVmResponse;
};

export type CreateVmResponse2 = CreateVmResponses[keyof CreateVmResponses];

export type ListSnapshotsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/vms/snapshots';
};

export type ListSnapshotsErrors = {
    /**
     * Error: SnapshotVmBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ListSnapshotsError = ListSnapshotsErrors[keyof ListSnapshotsErrors];

export type ListSnapshotsResponses = {
    /**
     * List of snapshots
     */
    200: ListSnapshotsResponse;
};

export type ListSnapshotsResponse2 = ListSnapshotsResponses[keyof ListSnapshotsResponses];

export type CreateSnapshotData = {
    body: CreateSnapshotRequest;
    path?: never;
    query?: never;
    url: '/v1/vms/snapshots';
};

export type CreateSnapshotErrors = {
    /**
     * Error: CreateSnapshotBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: ForkVmNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type CreateSnapshotError = CreateSnapshotErrors[keyof CreateSnapshotErrors];

export type CreateSnapshotResponses = {
    /**
     * Created snapshot
     */
    200: CreateSnapshotResponse;
};

export type CreateSnapshotResponse2 = CreateSnapshotResponses[keyof CreateSnapshotResponses];

export type ResizeVmData = {
    body: ResizeVmRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/vms/{id}/resize';
};

export type ResizeVmErrors = {
    /**
     * Error: InvalidParameters
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalResizeVmNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: ResizeFailed
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ResizeVmError = ResizeVmErrors[keyof ResizeVmErrors];

export type ResizeVmResponses = {
    200: ResizeVmResponse;
};

export type ResizeVmResponse2 = ResizeVmResponses[keyof ResizeVmResponses];

export type DeleteVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to delete
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}';
};

export type DeleteVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type DeleteVmError = DeleteVmErrors[keyof DeleteVmErrors];

export type DeleteVmResponses2 = {
    200: DeleteVmResponses;
};

export type DeleteVmResponse = DeleteVmResponses2[keyof DeleteVmResponses2];

export type GetVmData = {
    body?: never;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}';
};

export type GetVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type GetVmError = GetVmErrors[keyof GetVmErrors];

export type GetVmResponses = {
    200: GetVmResponse;
};

export type GetVmResponse2 = GetVmResponses[keyof GetVmResponses];

export type WaitVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to wait for
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/await';
};

export type WaitVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type WaitVmError = WaitVmErrors[keyof WaitVmErrors];

export type WaitVmResponses = {
    200: WaitVmResponse;
};

export type WaitVmResponse2 = WaitVmResponses[keyof WaitVmResponses];

export type ExecAwaitData = {
    body: ExecAwaitRequest;
    path: {
        /**
         * The ID of the VM to execute the command in
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/exec-await';
};

export type ExecAwaitErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ExecAwaitError = ExecAwaitErrors[keyof ExecAwaitErrors];

export type ExecAwaitResponses = {
    200: ExecAwaitVmResponse;
};

export type ExecAwaitResponse = ExecAwaitResponses[keyof ExecAwaitResponses];

export type GetFileData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to get the file from
         */
        vm_id: string;
        /**
         * The path of the file to get
         */
        filepath: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/files/{filepath}';
};

export type GetFileErrors = {
    /**
     * Error: FilesBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: FileNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type GetFileError = GetFileErrors[keyof GetFileErrors];

export type GetFileResponses = {
    200: FileSystemResponse;
};

export type GetFileResponse = GetFileResponses[keyof GetFileResponses];

export type PutFileData = {
    body: WriteFileRequest;
    path: {
        /**
         * The ID of the VM to put the file to
         */
        vm_id: string;
        /**
         * The path of the file to put
         */
        filepath: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/files/{filepath}';
};

export type PutFileErrors = {
    /**
     * Error: FilesBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: FileNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type PutFileError = PutFileErrors[keyof PutFileErrors];

export type PutFileResponses = {
    200: WriteFileResponse;
};

export type PutFileResponse = PutFileResponses[keyof PutFileResponses];

export type ForkVmData = {
    body: ForkVmRequest;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/fork';
};

export type ForkVmErrors = {
    /**
     * Error: CreateVmBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: ForkVmNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ForkVmError = ForkVmErrors[keyof ForkVmErrors];

export type ForkVmResponses = {
    200: ForkVmResponse;
};

export type ForkVmResponse2 = ForkVmResponses[keyof ForkVmResponses];

export type KillVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to kill
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/kill';
};

export type KillVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type KillVmError = KillVmErrors[keyof KillVmErrors];

export type KillVmResponses = {
    200: KillVmResponse;
};

export type KillVmResponse2 = KillVmResponses[keyof KillVmResponses];

export type OptimizeVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to optimize
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/optimize';
};

export type OptimizeVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type OptimizeVmError = OptimizeVmErrors[keyof OptimizeVmErrors];

export type OptimizeVmResponses = {
    200: OptimizeVmResponse;
};

export type OptimizeVmResponse2 = OptimizeVmResponses[keyof OptimizeVmResponses];

export type SnapshotVmData = {
    body: SnapshotVmRequest;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/snapshot';
};

export type SnapshotVmErrors = {
    /**
     * Error: SnapshotVmBadRequest
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type SnapshotVmError = SnapshotVmErrors[keyof SnapshotVmErrors];

export type SnapshotVmResponses = {
    /**
     * Created snapshot
     */
    200: SnapshotVmResponse;
};

export type SnapshotVmResponse2 = SnapshotVmResponses[keyof SnapshotVmResponses];

export type StartVmData = {
    body: StartVmRequest;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/start';
};

export type StartVmErrors = {
    /**
     * Error: VmDeleted
     */
    410: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: VmSubnetNotFound, VmCreateTmuxSession, StdIo, VmExitDuringStart, FirecrackerApiSocketNotFound, FirecrackerPidNotFound, Reqwest
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: VmStartTimeout
     */
    504: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type StartVmError = StartVmErrors[keyof StartVmErrors];

export type StartVmResponses = {
    200: StartedVmResponse;
};

export type StartVmResponse = StartVmResponses[keyof StartVmResponses];

export type StopVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to stop
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/stop';
};

export type StopVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type StopVmError = StopVmErrors[keyof StopVmErrors];

export type StopVmResponses = {
    200: StopVmResponse;
};

export type StopVmResponse2 = StopVmResponses[keyof StopVmResponses];

export type SuspendVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to suspend
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/suspend';
};

export type SuspendVmErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type SuspendVmError = SuspendVmErrors[keyof SuspendVmErrors];

export type SuspendVmResponses = {
    200: SuspendVmResponse;
};

export type SuspendVmResponse2 = SuspendVmResponses[keyof SuspendVmResponses];

export type ListTerminalsData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals';
};

export type ListTerminalsErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type ListTerminalsError = ListTerminalsErrors[keyof ListTerminalsErrors];

export type ListTerminalsResponses = {
    200: TerminalListResponse;
};

export type ListTerminalsResponse = ListTerminalsResponses[keyof ListTerminalsResponses];

export type GetTerminalLogsData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
        /**
         * The ID of the terminal session
         */
        terminal_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals/{terminal_id}/logs';
};

export type GetTerminalLogsErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type GetTerminalLogsError = GetTerminalLogsErrors[keyof GetTerminalLogsErrors];

export type GetTerminalLogsResponses = {
    200: TerminalLogsArrayResponse;
};

export type GetTerminalLogsResponse = GetTerminalLogsResponses[keyof GetTerminalLogsResponses];

export type GetTerminalXtermData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
        /**
         * The ID of the terminal session
         */
        terminal_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals/{terminal_id}/xterm-256color';
};

export type GetTerminalXtermErrors = {
    /**
     * Error: InternalError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type GetTerminalXtermError = GetTerminalXtermErrors[keyof GetTerminalXtermErrors];

export type GetTerminalXtermResponses = {
    200: TerminalLogsResponse;
};

export type GetTerminalXtermResponse = GetTerminalXtermResponses[keyof GetTerminalXtermResponses];

export type WatchFilesData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to watch files for
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/watch-files';
};

export type HandleDeployWebData = {
    body: FreestyleDeployWebPayload;
    path?: never;
    query?: never;
    url: '/web/v1/deploy';
};

export type HandleDeployWebErrors = {
    /**
     * failed to deploy
     */
    400: FreestyleDeployWebErrorResponse;
};

export type HandleDeployWebError = HandleDeployWebErrors[keyof HandleDeployWebErrors];

export type HandleDeployWebResponses = {
    /**
     * successfully deployed
     */
    200: FreestyleDeployWebSuccessResponseV2;
};

export type HandleDeployWebResponse = HandleDeployWebResponses[keyof HandleDeployWebResponses];

export type HandleDeployWebV2Data = {
    body: FreestyleDeployWebPayloadV2;
    path?: never;
    query?: never;
    url: '/web/v1/deployment';
};

export type HandleDeployWebV2Errors = {
    /**
     * Possible errors: WebDeploymentBadRequest, InvalidDomains, EntrypointNotFound, NoEntrypointFound
     */
    400: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: Forbidden, NoDomainOwnership
     */
    403: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Error: DeploymentNotFound
     */
    404: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: Internal, DomainMappingError, UploadError, LockfileError
     */
    500: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
    /**
     * Possible errors: CertificateProvisioningError, ServerDeploymentFailed
     */
    502: {
        /**
         * Error code in SCREAMING_SNAKE_CASE
         */
        error: string;
        /**
         * Human-readable error message
         */
        message: string;
    };
};

export type HandleDeployWebV2Error = HandleDeployWebV2Errors[keyof HandleDeployWebV2Errors];

export type HandleDeployWebV2Responses = {
    /**
     * successfully deployed
     */
    200: FreestyleDeployWebSuccessResponseV2;
};

export type HandleDeployWebV2Response = HandleDeployWebV2Responses[keyof HandleDeployWebV2Responses];

export type HandleListWebDeploysData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Maximum number of repositories to return
         */
        limit: number;
        /**
         * Offset for the list of repositories
         */
        offset: number;
    };
    url: '/web/v1/deployments';
};

export type HandleListWebDeploysErrors = {
    500: {
        message: string;
    };
};

export type HandleListWebDeploysError = HandleListWebDeploysErrors[keyof HandleListWebDeploysErrors];

export type HandleListWebDeploysResponses = {
    200: {
        entries: Array<DeploymentLogEntry>;
        total: number;
        offset: number;
    };
};

export type HandleListWebDeploysResponse = HandleListWebDeploysResponses[keyof HandleListWebDeploysResponses];

export type HandleGetWebDeployDetailsData = {
    body?: never;
    path: {
        deployment_id: string;
    };
    query?: never;
    url: '/web/v1/deployments/{deployment_id}';
};

export type ClientOptions = {
    baseUrl: 'https://api.freestyle.sh' | (string & {});
};