// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getApiHealth, getApiHealthSandbox, postApiAuthAnonymousSignUp, getApiUsers, postApiUsers, deleteApiUsersById, getApiUsersById, patchApiUsersById, getApiBooks, postApiBooks, getApiBooksById, postApiBooksByIdBorrow, postApiBooksByIdReturn, postApiDevServerStart, getApiIntegrationsGithubRepos, getApiIntegrationsGithubFrameworkDetection, getApiIntegrationsGithubPrs, postApiIntegrationsGithubPrsBackfill, postApiIntegrationsGithubPrsBackfillRepo, getApiIntegrationsGithubPrsCode, postApiIntegrationsGithubPrsOpen, postApiIntegrationsGithubPrsMerge, postApiIntegrationsGithubPrsClose, postApiIntegrationsGithubPrsMergeSimple, getApiIntegrationsGithubPrsRaw, getApiIntegrationsGithubPrsFiles, getApiIntegrationsGithubPrsFileContents, postApiIntegrationsGithubPrsFileContentsBatch, postApiIntegrationsGithubInstallState, getApiIntegrationsGithubOauthToken, getApiIntegrationsGithubDefaultBranch, getApiIntegrationsGithubBranches, postApiMorphTaskRunsByTaskRunIdResume, postApiMorphTaskRunsByTaskRunIdIsPaused, postApiMorphTaskRunsByTaskRunIdRefreshGithubAuth, postApiMorphSetupInstance, getApiMorphInstances, postApiOrchestrateMessage, getApiOrchestrateTasks, getApiOrchestrateTasksByTaskId, postApiOrchestrateTasksByTaskIdCancel, getApiOrchestrateMetrics, postApiPveLxcTaskRunsByTaskRunIdResume, postApiPveLxcPreviewInstancesStart, postApiPveLxcPreviewInstancesByInstanceIdExec, deleteApiPveLxcPreviewInstancesByInstanceId, postApiPveLxcPreviewInstancesByInstanceIdReadFile, postApiPveLxcTaskRunsByTaskRunIdIsStopped, getApiEnvironments, postApiEnvironments, deleteApiEnvironmentsById, getApiEnvironmentsById, patchApiEnvironmentsById, getApiEnvironmentsByIdVars, patchApiEnvironmentsByIdVars, patchApiEnvironmentsByIdPorts, getApiEnvironmentsByIdSnapshots, postApiEnvironmentsByIdSnapshots, postApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivate, postApiSandboxesStart, postApiSandboxesByIdSetupProviders, postApiSandboxesPrewarm, postApiSandboxesByIdRefreshGithubAuth, postApiSandboxesByIdEnv, postApiSandboxesByIdRunScripts, postApiSandboxesByIdStop, getApiSandboxesByIdStatus, postApiSandboxesByIdPublishDevcontainer, getApiSandboxesByIdSsh, postApiSandboxesByIdResume, postApiSandboxesByIdDiscoverRepos, getApiTeams, postApiTeams, postApiBranchesGenerate, postApiCodeReviewStart, getApiConfigSandbox, getApiWorkspaceConfigs, postApiWorkspaceConfigs, getApiPreviewConfigs, postApiPreviewConfigs, deleteApiPreviewConfigsByPreviewConfigId, getApiPreviewConfigsByPreviewConfigIdRuns, getApiPreviewTestCheckAccess, getApiPreviewTestJobs, postApiPreviewTestJobs, postApiPreviewTestJobsByPreviewRunIdDispatch, deleteApiPreviewTestJobsByPreviewRunId, getApiPreviewTestJobsByPreviewRunId, postApiPreviewTestJobsByPreviewRunIdRetry, deleteApiEditorSettings, getApiEditorSettings, postApiEditorSettings, postApiSettingsTestAnthropicConnection, postApiWorktreesRemove, getApiModels, patchApiModelsByNameEnabled, postApiModelsReorder, postApiModelsRefresh, postApiModelsSeed, getApiProviders, deleteApiProvidersById, getApiProvidersById, putApiProvidersById, postApiProvidersByIdTest, patchApiProvidersByIdEnabled, getApiProvidersStatus, getApiApiKeys, putApiApiKeys, deleteApiApiKeysByEnvVar } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetApiHealthData, GetApiHealthSandboxData, PostApiAuthAnonymousSignUpData, PostApiAuthAnonymousSignUpResponse, GetApiUsersData, GetApiUsersResponse, PostApiUsersData, PostApiUsersError, PostApiUsersResponse, DeleteApiUsersByIdData, DeleteApiUsersByIdError, DeleteApiUsersByIdResponse, GetApiUsersByIdData, PatchApiUsersByIdData, PatchApiUsersByIdError, PatchApiUsersByIdResponse, GetApiBooksData, PostApiBooksData, PostApiBooksError, PostApiBooksResponse, GetApiBooksByIdData, PostApiBooksByIdBorrowData, PostApiBooksByIdBorrowError, PostApiBooksByIdBorrowResponse, PostApiBooksByIdReturnData, PostApiBooksByIdReturnError, PostApiBooksByIdReturnResponse, PostApiDevServerStartData, PostApiDevServerStartError, PostApiDevServerStartResponse, GetApiIntegrationsGithubReposData, GetApiIntegrationsGithubReposResponse, GetApiIntegrationsGithubFrameworkDetectionData, GetApiIntegrationsGithubPrsData, GetApiIntegrationsGithubPrsResponse, PostApiIntegrationsGithubPrsBackfillData, PostApiIntegrationsGithubPrsBackfillRepoData, GetApiIntegrationsGithubPrsCodeData, PostApiIntegrationsGithubPrsOpenData, PostApiIntegrationsGithubPrsOpenResponse, PostApiIntegrationsGithubPrsMergeData, PostApiIntegrationsGithubPrsMergeResponse, PostApiIntegrationsGithubPrsCloseData, PostApiIntegrationsGithubPrsCloseResponse, PostApiIntegrationsGithubPrsMergeSimpleData, PostApiIntegrationsGithubPrsMergeSimpleResponse, GetApiIntegrationsGithubPrsRawData, GetApiIntegrationsGithubPrsFilesData, GetApiIntegrationsGithubPrsFileContentsData, PostApiIntegrationsGithubPrsFileContentsBatchData, PostApiIntegrationsGithubPrsFileContentsBatchResponse, PostApiIntegrationsGithubInstallStateData, PostApiIntegrationsGithubInstallStateResponse, GetApiIntegrationsGithubOauthTokenData, GetApiIntegrationsGithubDefaultBranchData, GetApiIntegrationsGithubBranchesData, GetApiIntegrationsGithubBranchesResponse, PostApiMorphTaskRunsByTaskRunIdResumeData, PostApiMorphTaskRunsByTaskRunIdResumeResponse, PostApiMorphTaskRunsByTaskRunIdIsPausedData, PostApiMorphTaskRunsByTaskRunIdIsPausedResponse, PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthData, PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthResponse, PostApiMorphSetupInstanceData, PostApiMorphSetupInstanceResponse, GetApiMorphInstancesData, PostApiOrchestrateMessageData, PostApiOrchestrateMessageResponse, GetApiOrchestrateTasksData, GetApiOrchestrateTasksByTaskIdData, PostApiOrchestrateTasksByTaskIdCancelData, PostApiOrchestrateTasksByTaskIdCancelResponse, GetApiOrchestrateMetricsData, PostApiPveLxcTaskRunsByTaskRunIdResumeData, PostApiPveLxcTaskRunsByTaskRunIdResumeResponse, PostApiPveLxcPreviewInstancesStartData, PostApiPveLxcPreviewInstancesStartResponse, PostApiPveLxcPreviewInstancesByInstanceIdExecData, PostApiPveLxcPreviewInstancesByInstanceIdExecResponse, DeleteApiPveLxcPreviewInstancesByInstanceIdData, DeleteApiPveLxcPreviewInstancesByInstanceIdResponse, PostApiPveLxcPreviewInstancesByInstanceIdReadFileData, PostApiPveLxcPreviewInstancesByInstanceIdReadFileResponse, PostApiPveLxcTaskRunsByTaskRunIdIsStoppedData, PostApiPveLxcTaskRunsByTaskRunIdIsStoppedResponse, GetApiEnvironmentsData, PostApiEnvironmentsData, PostApiEnvironmentsResponse, DeleteApiEnvironmentsByIdData, DeleteApiEnvironmentsByIdResponse, GetApiEnvironmentsByIdData, PatchApiEnvironmentsByIdData, PatchApiEnvironmentsByIdResponse, GetApiEnvironmentsByIdVarsData, PatchApiEnvironmentsByIdVarsData, PatchApiEnvironmentsByIdVarsResponse, PatchApiEnvironmentsByIdPortsData, PatchApiEnvironmentsByIdPortsResponse, GetApiEnvironmentsByIdSnapshotsData, PostApiEnvironmentsByIdSnapshotsData, PostApiEnvironmentsByIdSnapshotsResponse, PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateData, PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateResponse, PostApiSandboxesStartData, PostApiSandboxesStartResponse, PostApiSandboxesByIdSetupProvidersData, PostApiSandboxesByIdSetupProvidersResponse, PostApiSandboxesPrewarmData, PostApiSandboxesPrewarmResponse, PostApiSandboxesByIdRefreshGithubAuthData, PostApiSandboxesByIdRefreshGithubAuthResponse, PostApiSandboxesByIdEnvData, PostApiSandboxesByIdEnvResponse, PostApiSandboxesByIdRunScriptsData, PostApiSandboxesByIdRunScriptsResponse, PostApiSandboxesByIdStopData, PostApiSandboxesByIdStopResponse, GetApiSandboxesByIdStatusData, PostApiSandboxesByIdPublishDevcontainerData, PostApiSandboxesByIdPublishDevcontainerResponse, GetApiSandboxesByIdSshData, PostApiSandboxesByIdResumeData, PostApiSandboxesByIdResumeResponse, PostApiSandboxesByIdDiscoverReposData, PostApiSandboxesByIdDiscoverReposResponse, GetApiTeamsData, PostApiTeamsData, PostApiTeamsError, PostApiTeamsResponse, PostApiBranchesGenerateData, PostApiBranchesGenerateResponse, PostApiCodeReviewStartData, PostApiCodeReviewStartResponse, GetApiConfigSandboxData, GetApiWorkspaceConfigsData, PostApiWorkspaceConfigsData, PostApiWorkspaceConfigsResponse, GetApiPreviewConfigsData, PostApiPreviewConfigsData, PostApiPreviewConfigsResponse, DeleteApiPreviewConfigsByPreviewConfigIdData, DeleteApiPreviewConfigsByPreviewConfigIdResponse, GetApiPreviewConfigsByPreviewConfigIdRunsData, GetApiPreviewTestCheckAccessData, GetApiPreviewTestJobsData, PostApiPreviewTestJobsData, PostApiPreviewTestJobsResponse, PostApiPreviewTestJobsByPreviewRunIdDispatchData, PostApiPreviewTestJobsByPreviewRunIdDispatchResponse, DeleteApiPreviewTestJobsByPreviewRunIdData, DeleteApiPreviewTestJobsByPreviewRunIdResponse, GetApiPreviewTestJobsByPreviewRunIdData, PostApiPreviewTestJobsByPreviewRunIdRetryData, PostApiPreviewTestJobsByPreviewRunIdRetryResponse, DeleteApiEditorSettingsData, DeleteApiEditorSettingsResponse, GetApiEditorSettingsData, PostApiEditorSettingsData, PostApiEditorSettingsResponse, PostApiSettingsTestAnthropicConnectionData, PostApiSettingsTestAnthropicConnectionResponse, PostApiWorktreesRemoveData, PostApiWorktreesRemoveResponse, GetApiModelsData, PatchApiModelsByNameEnabledData, PatchApiModelsByNameEnabledResponse, PostApiModelsReorderData, PostApiModelsReorderResponse, PostApiModelsRefreshData, PostApiModelsRefreshResponse, PostApiModelsSeedData, PostApiModelsSeedResponse, GetApiProvidersData, DeleteApiProvidersByIdData, DeleteApiProvidersByIdResponse, GetApiProvidersByIdData, PutApiProvidersByIdData, PutApiProvidersByIdResponse, PostApiProvidersByIdTestData, PostApiProvidersByIdTestResponse, PatchApiProvidersByIdEnabledData, PatchApiProvidersByIdEnabledResponse, GetApiProvidersStatusData, GetApiApiKeysData, PutApiApiKeysData, PutApiApiKeysResponse, DeleteApiApiKeysByEnvVarData, DeleteApiApiKeysByEnvVarResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getApiHealthQueryKey = (options?: Options<GetApiHealthData>) => createQueryKey('getApiHealth', options);

/**
 * Health check endpoint
 */
export const getApiHealthOptions = (options?: Options<GetApiHealthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiHealth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiHealthQueryKey(options)
    });
};

export const getApiHealthSandboxQueryKey = (options?: Options<GetApiHealthSandboxData>) => createQueryKey('getApiHealthSandbox', options);

/**
 * Sandbox provider health check
 * Tests connectivity to the active sandbox provider (Morph or PVE LXC)
 */
export const getApiHealthSandboxOptions = (options?: Options<GetApiHealthSandboxData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiHealthSandbox({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiHealthSandboxQueryKey(options)
    });
};

/**
 * Create an anonymous user for public repo access
 */
export const postApiAuthAnonymousSignUpMutation = (options?: Partial<Options<PostApiAuthAnonymousSignUpData>>): UseMutationOptions<PostApiAuthAnonymousSignUpResponse, DefaultError, Options<PostApiAuthAnonymousSignUpData>> => {
    const mutationOptions: UseMutationOptions<PostApiAuthAnonymousSignUpResponse, DefaultError, Options<PostApiAuthAnonymousSignUpData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiAuthAnonymousSignUp({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiUsersQueryKey = (options?: Options<GetApiUsersData>) => createQueryKey('getApiUsers', options);

/**
 * List all users
 */
export const getApiUsersOptions = (options?: Options<GetApiUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiUsersQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getApiUsersInfiniteQueryKey = (options?: Options<GetApiUsersData>): QueryKey<Options<GetApiUsersData>> => createQueryKey('getApiUsers', options, true);

/**
 * List all users
 */
export const getApiUsersInfiniteOptions = (options?: Options<GetApiUsersData>) => {
    return infiniteQueryOptions<GetApiUsersResponse, DefaultError, InfiniteData<GetApiUsersResponse>, QueryKey<Options<GetApiUsersData>>, string | Pick<QueryKey<Options<GetApiUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiUsersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiUsers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiUsersInfiniteQueryKey(options)
    });
};

/**
 * Create a new user
 */
export const postApiUsersMutation = (options?: Partial<Options<PostApiUsersData>>): UseMutationOptions<PostApiUsersResponse, PostApiUsersError, Options<PostApiUsersData>> => {
    const mutationOptions: UseMutationOptions<PostApiUsersResponse, PostApiUsersError, Options<PostApiUsersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiUsers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user
 */
export const deleteApiUsersByIdMutation = (options?: Partial<Options<DeleteApiUsersByIdData>>): UseMutationOptions<DeleteApiUsersByIdResponse, DeleteApiUsersByIdError, Options<DeleteApiUsersByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiUsersByIdResponse, DeleteApiUsersByIdError, Options<DeleteApiUsersByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiUsersById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiUsersByIdQueryKey = (options: Options<GetApiUsersByIdData>) => createQueryKey('getApiUsersById', options);

/**
 * Get a user by ID
 */
export const getApiUsersByIdOptions = (options: Options<GetApiUsersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiUsersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiUsersByIdQueryKey(options)
    });
};

/**
 * Update a user
 */
export const patchApiUsersByIdMutation = (options?: Partial<Options<PatchApiUsersByIdData>>): UseMutationOptions<PatchApiUsersByIdResponse, PatchApiUsersByIdError, Options<PatchApiUsersByIdData>> => {
    const mutationOptions: UseMutationOptions<PatchApiUsersByIdResponse, PatchApiUsersByIdError, Options<PatchApiUsersByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiUsersById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiBooksQueryKey = (options?: Options<GetApiBooksData>) => createQueryKey('getApiBooks', options);

/**
 * List all books
 */
export const getApiBooksOptions = (options?: Options<GetApiBooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiBooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiBooksQueryKey(options)
    });
};

/**
 * Add a new book
 */
export const postApiBooksMutation = (options?: Partial<Options<PostApiBooksData>>): UseMutationOptions<PostApiBooksResponse, PostApiBooksError, Options<PostApiBooksData>> => {
    const mutationOptions: UseMutationOptions<PostApiBooksResponse, PostApiBooksError, Options<PostApiBooksData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiBooks({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiBooksByIdQueryKey = (options: Options<GetApiBooksByIdData>) => createQueryKey('getApiBooksById', options);

/**
 * Get a book by ID
 */
export const getApiBooksByIdOptions = (options: Options<GetApiBooksByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiBooksById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiBooksByIdQueryKey(options)
    });
};

/**
 * Borrow a book
 */
export const postApiBooksByIdBorrowMutation = (options?: Partial<Options<PostApiBooksByIdBorrowData>>): UseMutationOptions<PostApiBooksByIdBorrowResponse, PostApiBooksByIdBorrowError, Options<PostApiBooksByIdBorrowData>> => {
    const mutationOptions: UseMutationOptions<PostApiBooksByIdBorrowResponse, PostApiBooksByIdBorrowError, Options<PostApiBooksByIdBorrowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiBooksByIdBorrow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Return a book
 */
export const postApiBooksByIdReturnMutation = (options?: Partial<Options<PostApiBooksByIdReturnData>>): UseMutationOptions<PostApiBooksByIdReturnResponse, PostApiBooksByIdReturnError, Options<PostApiBooksByIdReturnData>> => {
    const mutationOptions: UseMutationOptions<PostApiBooksByIdReturnResponse, PostApiBooksByIdReturnError, Options<PostApiBooksByIdReturnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiBooksByIdReturn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start a new development server
 * Creates a new development server instance with VSCode and worker services for running tasks
 */
export const postApiDevServerStartMutation = (options?: Partial<Options<PostApiDevServerStartData>>): UseMutationOptions<PostApiDevServerStartResponse, PostApiDevServerStartError, Options<PostApiDevServerStartData>> => {
    const mutationOptions: UseMutationOptions<PostApiDevServerStartResponse, PostApiDevServerStartError, Options<PostApiDevServerStartData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiDevServerStart({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiIntegrationsGithubReposQueryKey = (options: Options<GetApiIntegrationsGithubReposData>) => createQueryKey('getApiIntegrationsGithubRepos', options);

/**
 * List repos per GitHub App installation for a team
 */
export const getApiIntegrationsGithubReposOptions = (options: Options<GetApiIntegrationsGithubReposData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubRepos({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubReposQueryKey(options)
    });
};

export const getApiIntegrationsGithubReposInfiniteQueryKey = (options: Options<GetApiIntegrationsGithubReposData>): QueryKey<Options<GetApiIntegrationsGithubReposData>> => createQueryKey('getApiIntegrationsGithubRepos', options, true);

/**
 * List repos per GitHub App installation for a team
 */
export const getApiIntegrationsGithubReposInfiniteOptions = (options: Options<GetApiIntegrationsGithubReposData>) => {
    return infiniteQueryOptions<GetApiIntegrationsGithubReposResponse, DefaultError, InfiniteData<GetApiIntegrationsGithubReposResponse>, QueryKey<Options<GetApiIntegrationsGithubReposData>>, number | Pick<QueryKey<Options<GetApiIntegrationsGithubReposData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiIntegrationsGithubReposData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiIntegrationsGithubRepos({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubReposInfiniteQueryKey(options)
    });
};

export const getApiIntegrationsGithubFrameworkDetectionQueryKey = (options: Options<GetApiIntegrationsGithubFrameworkDetectionData>) => createQueryKey('getApiIntegrationsGithubFrameworkDetection', options);

/**
 * Detect framework and package manager for a GitHub repository
 */
export const getApiIntegrationsGithubFrameworkDetectionOptions = (options: Options<GetApiIntegrationsGithubFrameworkDetectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubFrameworkDetection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubFrameworkDetectionQueryKey(options)
    });
};

export const getApiIntegrationsGithubPrsQueryKey = (options: Options<GetApiIntegrationsGithubPrsData>) => createQueryKey('getApiIntegrationsGithubPrs', options);

/**
 * List pull requests across a GitHub App installation for a team
 */
export const getApiIntegrationsGithubPrsOptions = (options: Options<GetApiIntegrationsGithubPrsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubPrs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsQueryKey(options)
    });
};

export const getApiIntegrationsGithubPrsInfiniteQueryKey = (options: Options<GetApiIntegrationsGithubPrsData>): QueryKey<Options<GetApiIntegrationsGithubPrsData>> => createQueryKey('getApiIntegrationsGithubPrs', options, true);

/**
 * List pull requests across a GitHub App installation for a team
 */
export const getApiIntegrationsGithubPrsInfiniteOptions = (options: Options<GetApiIntegrationsGithubPrsData>) => {
    return infiniteQueryOptions<GetApiIntegrationsGithubPrsResponse, DefaultError, InfiniteData<GetApiIntegrationsGithubPrsResponse>, QueryKey<Options<GetApiIntegrationsGithubPrsData>>, number | Pick<QueryKey<Options<GetApiIntegrationsGithubPrsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiIntegrationsGithubPrsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiIntegrationsGithubPrs({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsInfiniteQueryKey(options)
    });
};

/**
 * Backfill a single PR by URL and persist to Convex
 */
export const postApiIntegrationsGithubPrsBackfillMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsBackfillData>>): UseMutationOptions<unknown, DefaultError, Options<PostApiIntegrationsGithubPrsBackfillData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostApiIntegrationsGithubPrsBackfillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsBackfill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Backfill all PRs for a repo and persist to Convex
 */
export const postApiIntegrationsGithubPrsBackfillRepoMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsBackfillRepoData>>): UseMutationOptions<unknown, DefaultError, Options<PostApiIntegrationsGithubPrsBackfillRepoData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostApiIntegrationsGithubPrsBackfillRepoData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsBackfillRepo({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiIntegrationsGithubPrsCodeQueryKey = (options: Options<GetApiIntegrationsGithubPrsCodeData>) => createQueryKey('getApiIntegrationsGithubPrsCode', options);

/**
 * Fetch PR files, patches, and optional head contents
 */
export const getApiIntegrationsGithubPrsCodeOptions = (options: Options<GetApiIntegrationsGithubPrsCodeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubPrsCode({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsCodeQueryKey(options)
    });
};

/**
 * Create or update GitHub pull requests for a task run using the user's GitHub OAuth token
 */
export const postApiIntegrationsGithubPrsOpenMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsOpenData>>): UseMutationOptions<PostApiIntegrationsGithubPrsOpenResponse, DefaultError, Options<PostApiIntegrationsGithubPrsOpenData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubPrsOpenResponse, DefaultError, Options<PostApiIntegrationsGithubPrsOpenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsOpen({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge GitHub pull requests for a task run using the user's GitHub OAuth token
 */
export const postApiIntegrationsGithubPrsMergeMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsMergeData>>): UseMutationOptions<PostApiIntegrationsGithubPrsMergeResponse, DefaultError, Options<PostApiIntegrationsGithubPrsMergeData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubPrsMergeResponse, DefaultError, Options<PostApiIntegrationsGithubPrsMergeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsMerge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Close a GitHub pull request using the user's GitHub OAuth token
 */
export const postApiIntegrationsGithubPrsCloseMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsCloseData>>): UseMutationOptions<PostApiIntegrationsGithubPrsCloseResponse, DefaultError, Options<PostApiIntegrationsGithubPrsCloseData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubPrsCloseResponse, DefaultError, Options<PostApiIntegrationsGithubPrsCloseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsClose({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge a GitHub pull request using the user's GitHub OAuth token
 */
export const postApiIntegrationsGithubPrsMergeSimpleMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsMergeSimpleData>>): UseMutationOptions<PostApiIntegrationsGithubPrsMergeSimpleResponse, DefaultError, Options<PostApiIntegrationsGithubPrsMergeSimpleData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubPrsMergeSimpleResponse, DefaultError, Options<PostApiIntegrationsGithubPrsMergeSimpleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsMergeSimple({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiIntegrationsGithubPrsRawQueryKey = (options: Options<GetApiIntegrationsGithubPrsRawData>) => createQueryKey('getApiIntegrationsGithubPrsRaw', options);

/**
 * Fetch raw .patch or .diff for a PR (private repos supported)
 */
export const getApiIntegrationsGithubPrsRawOptions = (options: Options<GetApiIntegrationsGithubPrsRawData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubPrsRaw({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsRawQueryKey(options)
    });
};

export const getApiIntegrationsGithubPrsFilesQueryKey = (options: Options<GetApiIntegrationsGithubPrsFilesData>) => createQueryKey('getApiIntegrationsGithubPrsFiles', options);

/**
 * List PR files without contents (fast)
 */
export const getApiIntegrationsGithubPrsFilesOptions = (options: Options<GetApiIntegrationsGithubPrsFilesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubPrsFiles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsFilesQueryKey(options)
    });
};

export const getApiIntegrationsGithubPrsFileContentsQueryKey = (options: Options<GetApiIntegrationsGithubPrsFileContentsData>) => createQueryKey('getApiIntegrationsGithubPrsFileContents', options);

/**
 * Fetch base/head contents for a single file in a PR
 */
export const getApiIntegrationsGithubPrsFileContentsOptions = (options: Options<GetApiIntegrationsGithubPrsFileContentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubPrsFileContents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubPrsFileContentsQueryKey(options)
    });
};

/**
 * Batch fetch base/head contents for many files in a PR using git blobs
 */
export const postApiIntegrationsGithubPrsFileContentsBatchMutation = (options?: Partial<Options<PostApiIntegrationsGithubPrsFileContentsBatchData>>): UseMutationOptions<PostApiIntegrationsGithubPrsFileContentsBatchResponse, DefaultError, Options<PostApiIntegrationsGithubPrsFileContentsBatchData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubPrsFileContentsBatchResponse, DefaultError, Options<PostApiIntegrationsGithubPrsFileContentsBatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubPrsFileContentsBatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate a signed install state token for GitHub App installation
 */
export const postApiIntegrationsGithubInstallStateMutation = (options?: Partial<Options<PostApiIntegrationsGithubInstallStateData>>): UseMutationOptions<PostApiIntegrationsGithubInstallStateResponse, DefaultError, Options<PostApiIntegrationsGithubInstallStateData>> => {
    const mutationOptions: UseMutationOptions<PostApiIntegrationsGithubInstallStateResponse, DefaultError, Options<PostApiIntegrationsGithubInstallStateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiIntegrationsGithubInstallState({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiIntegrationsGithubOauthTokenQueryKey = (options?: Options<GetApiIntegrationsGithubOauthTokenData>) => createQueryKey('getApiIntegrationsGithubOauthToken', options);

/**
 * Get the current user's GitHub OAuth access token
 */
export const getApiIntegrationsGithubOauthTokenOptions = (options?: Options<GetApiIntegrationsGithubOauthTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubOauthToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubOauthTokenQueryKey(options)
    });
};

export const getApiIntegrationsGithubDefaultBranchQueryKey = (options: Options<GetApiIntegrationsGithubDefaultBranchData>) => createQueryKey('getApiIntegrationsGithubDefaultBranch', options);

/**
 * Get the default branch for a repository (fast - single API call)
 */
export const getApiIntegrationsGithubDefaultBranchOptions = (options: Options<GetApiIntegrationsGithubDefaultBranchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubDefaultBranch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubDefaultBranchQueryKey(options)
    });
};

export const getApiIntegrationsGithubBranchesQueryKey = (options: Options<GetApiIntegrationsGithubBranchesData>) => createQueryKey('getApiIntegrationsGithubBranches', options);

/**
 * List branches for a repository with optional search filter
 */
export const getApiIntegrationsGithubBranchesOptions = (options: Options<GetApiIntegrationsGithubBranchesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiIntegrationsGithubBranches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubBranchesQueryKey(options)
    });
};

export const getApiIntegrationsGithubBranchesInfiniteQueryKey = (options: Options<GetApiIntegrationsGithubBranchesData>): QueryKey<Options<GetApiIntegrationsGithubBranchesData>> => createQueryKey('getApiIntegrationsGithubBranches', options, true);

/**
 * List branches for a repository with optional search filter
 */
export const getApiIntegrationsGithubBranchesInfiniteOptions = (options: Options<GetApiIntegrationsGithubBranchesData>) => {
    return infiniteQueryOptions<GetApiIntegrationsGithubBranchesResponse, DefaultError, InfiniteData<GetApiIntegrationsGithubBranchesResponse>, QueryKey<Options<GetApiIntegrationsGithubBranchesData>>, number | null | Pick<QueryKey<Options<GetApiIntegrationsGithubBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiIntegrationsGithubBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiIntegrationsGithubBranches({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiIntegrationsGithubBranchesInfiniteQueryKey(options)
    });
};

/**
 * Resume the Morph instance backing a task run
 */
export const postApiMorphTaskRunsByTaskRunIdResumeMutation = (options?: Partial<Options<PostApiMorphTaskRunsByTaskRunIdResumeData>>): UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdResumeResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdResumeData>> => {
    const mutationOptions: UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdResumeResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdResumeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiMorphTaskRunsByTaskRunIdResume({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Check if the Morph instance backing a task run is paused
 */
export const postApiMorphTaskRunsByTaskRunIdIsPausedMutation = (options?: Partial<Options<PostApiMorphTaskRunsByTaskRunIdIsPausedData>>): UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdIsPausedResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdIsPausedData>> => {
    const mutationOptions: UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdIsPausedResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdIsPausedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiMorphTaskRunsByTaskRunIdIsPaused({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh GitHub authentication on a Morph instance
 * Re-authenticates the GitHub CLI inside a running Morph VM with a fresh token. Useful when the token has expired or the user has re-connected their GitHub account.
 */
export const postApiMorphTaskRunsByTaskRunIdRefreshGithubAuthMutation = (options?: Partial<Options<PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthData>>): UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthData>> => {
    const mutationOptions: UseMutationOptions<PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthResponse, DefaultError, Options<PostApiMorphTaskRunsByTaskRunIdRefreshGithubAuthData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiMorphTaskRunsByTaskRunIdRefreshGithubAuth({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Setup a Morph instance with optional repository cloning
 */
export const postApiMorphSetupInstanceMutation = (options?: Partial<Options<PostApiMorphSetupInstanceData>>): UseMutationOptions<PostApiMorphSetupInstanceResponse, DefaultError, Options<PostApiMorphSetupInstanceData>> => {
    const mutationOptions: UseMutationOptions<PostApiMorphSetupInstanceResponse, DefaultError, Options<PostApiMorphSetupInstanceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiMorphSetupInstance({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiMorphInstancesQueryKey = (options?: Options<GetApiMorphInstancesData>) => createQueryKey('getApiMorphInstances', options);

/**
 * List Morph instances for the authenticated user
 */
export const getApiMorphInstancesOptions = (options?: Options<GetApiMorphInstancesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiMorphInstances({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiMorphInstancesQueryKey(options)
    });
};

/**
 * Send message to running agent
 * Send a message to a running agent via the mailbox MCP. The message is written to MAILBOX.json in the sandbox.
 */
export const postApiOrchestrateMessageMutation = (options?: Partial<Options<PostApiOrchestrateMessageData>>): UseMutationOptions<PostApiOrchestrateMessageResponse, DefaultError, Options<PostApiOrchestrateMessageData>> => {
    const mutationOptions: UseMutationOptions<PostApiOrchestrateMessageResponse, DefaultError, Options<PostApiOrchestrateMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiOrchestrateMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiOrchestrateTasksQueryKey = (options: Options<GetApiOrchestrateTasksData>) => createQueryKey('getApiOrchestrateTasks', options);

/**
 * List orchestration tasks
 * List orchestration tasks for a team with optional status filter and dependency info.
 */
export const getApiOrchestrateTasksOptions = (options: Options<GetApiOrchestrateTasksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiOrchestrateTasks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiOrchestrateTasksQueryKey(options)
    });
};

export const getApiOrchestrateTasksByTaskIdQueryKey = (options: Options<GetApiOrchestrateTasksByTaskIdData>) => createQueryKey('getApiOrchestrateTasksByTaskId', options);

/**
 * Get orchestration task
 * Get a single orchestration task by ID.
 */
export const getApiOrchestrateTasksByTaskIdOptions = (options: Options<GetApiOrchestrateTasksByTaskIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiOrchestrateTasksByTaskId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiOrchestrateTasksByTaskIdQueryKey(options)
    });
};

/**
 * Cancel orchestration task
 * Cancel an orchestration task. Optionally cascade to dependent tasks.
 */
export const postApiOrchestrateTasksByTaskIdCancelMutation = (options?: Partial<Options<PostApiOrchestrateTasksByTaskIdCancelData>>): UseMutationOptions<PostApiOrchestrateTasksByTaskIdCancelResponse, DefaultError, Options<PostApiOrchestrateTasksByTaskIdCancelData>> => {
    const mutationOptions: UseMutationOptions<PostApiOrchestrateTasksByTaskIdCancelResponse, DefaultError, Options<PostApiOrchestrateTasksByTaskIdCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiOrchestrateTasksByTaskIdCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiOrchestrateMetricsQueryKey = (options: Options<GetApiOrchestrateMetricsData>) => createQueryKey('getApiOrchestrateMetrics', options);

/**
 * Get orchestration metrics
 * Get orchestration summary metrics including task counts by status and active agents.
 */
export const getApiOrchestrateMetricsOptions = (options: Options<GetApiOrchestrateMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiOrchestrateMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiOrchestrateMetricsQueryKey(options)
    });
};

/**
 * Resume the PVE LXC container backing a task run
 */
export const postApiPveLxcTaskRunsByTaskRunIdResumeMutation = (options?: Partial<Options<PostApiPveLxcTaskRunsByTaskRunIdResumeData>>): UseMutationOptions<PostApiPveLxcTaskRunsByTaskRunIdResumeResponse, DefaultError, Options<PostApiPveLxcTaskRunsByTaskRunIdResumeData>> => {
    const mutationOptions: UseMutationOptions<PostApiPveLxcTaskRunsByTaskRunIdResumeResponse, DefaultError, Options<PostApiPveLxcTaskRunsByTaskRunIdResumeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPveLxcTaskRunsByTaskRunIdResume({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start a PVE LXC instance for preview jobs (internal)
 */
export const postApiPveLxcPreviewInstancesStartMutation = (options?: Partial<Options<PostApiPveLxcPreviewInstancesStartData>>): UseMutationOptions<PostApiPveLxcPreviewInstancesStartResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesStartData>> => {
    const mutationOptions: UseMutationOptions<PostApiPveLxcPreviewInstancesStartResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesStartData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPveLxcPreviewInstancesStart({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Execute a command in a PVE LXC instance for preview jobs (internal)
 */
export const postApiPveLxcPreviewInstancesByInstanceIdExecMutation = (options?: Partial<Options<PostApiPveLxcPreviewInstancesByInstanceIdExecData>>): UseMutationOptions<PostApiPveLxcPreviewInstancesByInstanceIdExecResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesByInstanceIdExecData>> => {
    const mutationOptions: UseMutationOptions<PostApiPveLxcPreviewInstancesByInstanceIdExecResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesByInstanceIdExecData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPveLxcPreviewInstancesByInstanceIdExec({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Stop a PVE LXC instance for preview jobs (internal)
 */
export const deleteApiPveLxcPreviewInstancesByInstanceIdMutation = (options?: Partial<Options<DeleteApiPveLxcPreviewInstancesByInstanceIdData>>): UseMutationOptions<DeleteApiPveLxcPreviewInstancesByInstanceIdResponse, DefaultError, Options<DeleteApiPveLxcPreviewInstancesByInstanceIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiPveLxcPreviewInstancesByInstanceIdResponse, DefaultError, Options<DeleteApiPveLxcPreviewInstancesByInstanceIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiPveLxcPreviewInstancesByInstanceId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Read a file from a PVE LXC instance for preview jobs (internal)
 */
export const postApiPveLxcPreviewInstancesByInstanceIdReadFileMutation = (options?: Partial<Options<PostApiPveLxcPreviewInstancesByInstanceIdReadFileData>>): UseMutationOptions<PostApiPveLxcPreviewInstancesByInstanceIdReadFileResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesByInstanceIdReadFileData>> => {
    const mutationOptions: UseMutationOptions<PostApiPveLxcPreviewInstancesByInstanceIdReadFileResponse, DefaultError, Options<PostApiPveLxcPreviewInstancesByInstanceIdReadFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPveLxcPreviewInstancesByInstanceIdReadFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Check if the PVE LXC container backing a task run is stopped
 */
export const postApiPveLxcTaskRunsByTaskRunIdIsStoppedMutation = (options?: Partial<Options<PostApiPveLxcTaskRunsByTaskRunIdIsStoppedData>>): UseMutationOptions<PostApiPveLxcTaskRunsByTaskRunIdIsStoppedResponse, DefaultError, Options<PostApiPveLxcTaskRunsByTaskRunIdIsStoppedData>> => {
    const mutationOptions: UseMutationOptions<PostApiPveLxcTaskRunsByTaskRunIdIsStoppedResponse, DefaultError, Options<PostApiPveLxcTaskRunsByTaskRunIdIsStoppedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPveLxcTaskRunsByTaskRunIdIsStopped({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiEnvironmentsQueryKey = (options: Options<GetApiEnvironmentsData>) => createQueryKey('getApiEnvironments', options);

/**
 * List environments for a team
 */
export const getApiEnvironmentsOptions = (options: Options<GetApiEnvironmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiEnvironments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiEnvironmentsQueryKey(options)
    });
};

/**
 * Create a new environment with snapshot
 */
export const postApiEnvironmentsMutation = (options?: Partial<Options<PostApiEnvironmentsData>>): UseMutationOptions<PostApiEnvironmentsResponse, DefaultError, Options<PostApiEnvironmentsData>> => {
    const mutationOptions: UseMutationOptions<PostApiEnvironmentsResponse, DefaultError, Options<PostApiEnvironmentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiEnvironments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an environment
 */
export const deleteApiEnvironmentsByIdMutation = (options?: Partial<Options<DeleteApiEnvironmentsByIdData>>): UseMutationOptions<DeleteApiEnvironmentsByIdResponse, DefaultError, Options<DeleteApiEnvironmentsByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiEnvironmentsByIdResponse, DefaultError, Options<DeleteApiEnvironmentsByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiEnvironmentsById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiEnvironmentsByIdQueryKey = (options: Options<GetApiEnvironmentsByIdData>) => createQueryKey('getApiEnvironmentsById', options);

/**
 * Get a specific environment
 */
export const getApiEnvironmentsByIdOptions = (options: Options<GetApiEnvironmentsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiEnvironmentsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiEnvironmentsByIdQueryKey(options)
    });
};

/**
 * Update environment metadata
 */
export const patchApiEnvironmentsByIdMutation = (options?: Partial<Options<PatchApiEnvironmentsByIdData>>): UseMutationOptions<PatchApiEnvironmentsByIdResponse, DefaultError, Options<PatchApiEnvironmentsByIdData>> => {
    const mutationOptions: UseMutationOptions<PatchApiEnvironmentsByIdResponse, DefaultError, Options<PatchApiEnvironmentsByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiEnvironmentsById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiEnvironmentsByIdVarsQueryKey = (options: Options<GetApiEnvironmentsByIdVarsData>) => createQueryKey('getApiEnvironmentsByIdVars', options);

/**
 * Get environment variables for a specific environment
 */
export const getApiEnvironmentsByIdVarsOptions = (options: Options<GetApiEnvironmentsByIdVarsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiEnvironmentsByIdVars({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiEnvironmentsByIdVarsQueryKey(options)
    });
};

/**
 * Update environment variables for a specific environment
 */
export const patchApiEnvironmentsByIdVarsMutation = (options?: Partial<Options<PatchApiEnvironmentsByIdVarsData>>): UseMutationOptions<PatchApiEnvironmentsByIdVarsResponse, DefaultError, Options<PatchApiEnvironmentsByIdVarsData>> => {
    const mutationOptions: UseMutationOptions<PatchApiEnvironmentsByIdVarsResponse, DefaultError, Options<PatchApiEnvironmentsByIdVarsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiEnvironmentsByIdVars({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update exposed ports for an environment
 */
export const patchApiEnvironmentsByIdPortsMutation = (options?: Partial<Options<PatchApiEnvironmentsByIdPortsData>>): UseMutationOptions<PatchApiEnvironmentsByIdPortsResponse, DefaultError, Options<PatchApiEnvironmentsByIdPortsData>> => {
    const mutationOptions: UseMutationOptions<PatchApiEnvironmentsByIdPortsResponse, DefaultError, Options<PatchApiEnvironmentsByIdPortsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiEnvironmentsByIdPorts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiEnvironmentsByIdSnapshotsQueryKey = (options: Options<GetApiEnvironmentsByIdSnapshotsData>) => createQueryKey('getApiEnvironmentsByIdSnapshots', options);

/**
 * List snapshot versions for an environment
 */
export const getApiEnvironmentsByIdSnapshotsOptions = (options: Options<GetApiEnvironmentsByIdSnapshotsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiEnvironmentsByIdSnapshots({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiEnvironmentsByIdSnapshotsQueryKey(options)
    });
};

/**
 * Create a new snapshot version from a running instance
 */
export const postApiEnvironmentsByIdSnapshotsMutation = (options?: Partial<Options<PostApiEnvironmentsByIdSnapshotsData>>): UseMutationOptions<PostApiEnvironmentsByIdSnapshotsResponse, DefaultError, Options<PostApiEnvironmentsByIdSnapshotsData>> => {
    const mutationOptions: UseMutationOptions<PostApiEnvironmentsByIdSnapshotsResponse, DefaultError, Options<PostApiEnvironmentsByIdSnapshotsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiEnvironmentsByIdSnapshots({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Activate a snapshot version for an environment
 */
export const postApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateMutation = (options?: Partial<Options<PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateData>>): UseMutationOptions<PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateResponse, DefaultError, Options<PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateData>> => {
    const mutationOptions: UseMutationOptions<PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateResponse, DefaultError, Options<PostApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiEnvironmentsByIdSnapshotsBySnapshotVersionIdActivate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start a sandbox environment
 */
export const postApiSandboxesStartMutation = (options?: Partial<Options<PostApiSandboxesStartData>>): UseMutationOptions<PostApiSandboxesStartResponse, DefaultError, Options<PostApiSandboxesStartData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesStartResponse, DefaultError, Options<PostApiSandboxesStartData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesStart({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set up provider auth on an existing sandbox
 * Configures Claude and Codex CLI auth (API keys, OAuth tokens, settings files) on an existing sandbox instance so coding CLIs work out of the box.
 */
export const postApiSandboxesByIdSetupProvidersMutation = (options?: Partial<Options<PostApiSandboxesByIdSetupProvidersData>>): UseMutationOptions<PostApiSandboxesByIdSetupProvidersResponse, DefaultError, Options<PostApiSandboxesByIdSetupProvidersData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdSetupProvidersResponse, DefaultError, Options<PostApiSandboxesByIdSetupProvidersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdSetupProviders({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Prewarm a sandbox instance for a repo
 * Creates a Morph instance in the background with the repo already cloned. Call this when the user starts typing a task description for faster startup.
 */
export const postApiSandboxesPrewarmMutation = (options?: Partial<Options<PostApiSandboxesPrewarmData>>): UseMutationOptions<PostApiSandboxesPrewarmResponse, DefaultError, Options<PostApiSandboxesPrewarmData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesPrewarmResponse, DefaultError, Options<PostApiSandboxesPrewarmData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesPrewarm({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh GitHub authentication inside a sandbox
 * Fetches a fresh GitHub token via Stack Auth and re-authenticates the GitHub CLI inside the sandbox.
 */
export const postApiSandboxesByIdRefreshGithubAuthMutation = (options?: Partial<Options<PostApiSandboxesByIdRefreshGithubAuthData>>): UseMutationOptions<PostApiSandboxesByIdRefreshGithubAuthResponse, DefaultError, Options<PostApiSandboxesByIdRefreshGithubAuthData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdRefreshGithubAuthResponse, DefaultError, Options<PostApiSandboxesByIdRefreshGithubAuthData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdRefreshGithubAuth({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Apply environment variables to a running sandbox
 */
export const postApiSandboxesByIdEnvMutation = (options?: Partial<Options<PostApiSandboxesByIdEnvData>>): UseMutationOptions<PostApiSandboxesByIdEnvResponse, DefaultError, Options<PostApiSandboxesByIdEnvData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdEnvResponse, DefaultError, Options<PostApiSandboxesByIdEnvData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdEnv({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Run maintenance and dev scripts in a sandbox
 * Runs maintenance and/or dev scripts in tmux sessions within the sandbox. This ensures scripts run in a managed way that can be properly cleaned up before snapshotting.
 */
export const postApiSandboxesByIdRunScriptsMutation = (options?: Partial<Options<PostApiSandboxesByIdRunScriptsData>>): UseMutationOptions<PostApiSandboxesByIdRunScriptsResponse, DefaultError, Options<PostApiSandboxesByIdRunScriptsData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdRunScriptsResponse, DefaultError, Options<PostApiSandboxesByIdRunScriptsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdRunScripts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Stop or pause a sandbox instance
 */
export const postApiSandboxesByIdStopMutation = (options?: Partial<Options<PostApiSandboxesByIdStopData>>): UseMutationOptions<PostApiSandboxesByIdStopResponse, DefaultError, Options<PostApiSandboxesByIdStopData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdStopResponse, DefaultError, Options<PostApiSandboxesByIdStopData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdStop({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiSandboxesByIdStatusQueryKey = (options: Options<GetApiSandboxesByIdStatusData>) => createQueryKey('getApiSandboxesByIdStatus', options);

/**
 * Get sandbox status and URLs
 */
export const getApiSandboxesByIdStatusOptions = (options: Options<GetApiSandboxesByIdStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiSandboxesByIdStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiSandboxesByIdStatusQueryKey(options)
    });
};

/**
 * Expose forwarded ports from devcontainer.json and persist networking info
 */
export const postApiSandboxesByIdPublishDevcontainerMutation = (options?: Partial<Options<PostApiSandboxesByIdPublishDevcontainerData>>): UseMutationOptions<PostApiSandboxesByIdPublishDevcontainerResponse, DefaultError, Options<PostApiSandboxesByIdPublishDevcontainerData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdPublishDevcontainerResponse, DefaultError, Options<PostApiSandboxesByIdPublishDevcontainerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdPublishDevcontainer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiSandboxesByIdSshQueryKey = (options: Options<GetApiSandboxesByIdSshData>) => createQueryKey('getApiSandboxesByIdSsh', options);

/**
 * Get SSH connection details for a sandbox
 * Returns SSH connection info for a sandbox. Use the returned sshCommand or accessToken to connect.
 */
export const getApiSandboxesByIdSshOptions = (options: Options<GetApiSandboxesByIdSshData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiSandboxesByIdSsh({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiSandboxesByIdSshQueryKey(options)
    });
};

/**
 * Resume a paused sandbox
 * Resumes a paused sandbox so it can accept SSH connections.
 */
export const postApiSandboxesByIdResumeMutation = (options?: Partial<Options<PostApiSandboxesByIdResumeData>>): UseMutationOptions<PostApiSandboxesByIdResumeResponse, DefaultError, Options<PostApiSandboxesByIdResumeData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdResumeResponse, DefaultError, Options<PostApiSandboxesByIdResumeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdResume({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Discover git repositories in sandbox workspace
 * Scans the sandbox workspace for git repositories and returns their GitHub remote URLs in owner/repo format.
 */
export const postApiSandboxesByIdDiscoverReposMutation = (options?: Partial<Options<PostApiSandboxesByIdDiscoverReposData>>): UseMutationOptions<PostApiSandboxesByIdDiscoverReposResponse, DefaultError, Options<PostApiSandboxesByIdDiscoverReposData>> => {
    const mutationOptions: UseMutationOptions<PostApiSandboxesByIdDiscoverReposResponse, DefaultError, Options<PostApiSandboxesByIdDiscoverReposData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSandboxesByIdDiscoverRepos({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiTeamsQueryKey = (options?: Options<GetApiTeamsData>) => createQueryKey('getApiTeams', options);

/**
 * List user's teams
 */
export const getApiTeamsOptions = (options?: Options<GetApiTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiTeamsQueryKey(options)
    });
};

/**
 * Create a new team
 */
export const postApiTeamsMutation = (options?: Partial<Options<PostApiTeamsData>>): UseMutationOptions<PostApiTeamsResponse, PostApiTeamsError, Options<PostApiTeamsData>> => {
    const mutationOptions: UseMutationOptions<PostApiTeamsResponse, PostApiTeamsError, Options<PostApiTeamsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiTeams({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Generate git branch names for task runs
 */
export const postApiBranchesGenerateMutation = (options?: Partial<Options<PostApiBranchesGenerateData>>): UseMutationOptions<PostApiBranchesGenerateResponse, DefaultError, Options<PostApiBranchesGenerateData>> => {
    const mutationOptions: UseMutationOptions<PostApiBranchesGenerateResponse, DefaultError, Options<PostApiBranchesGenerateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiBranchesGenerate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start an automated code review for a pull request
 */
export const postApiCodeReviewStartMutation = (options?: Partial<Options<PostApiCodeReviewStartData>>): UseMutationOptions<PostApiCodeReviewStartResponse, DefaultError, Options<PostApiCodeReviewStartData>> => {
    const mutationOptions: UseMutationOptions<PostApiCodeReviewStartResponse, DefaultError, Options<PostApiCodeReviewStartData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiCodeReviewStart({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiConfigSandboxQueryKey = (options?: Options<GetApiConfigSandboxData>) => createQueryKey('getApiConfigSandbox', options);

/**
 * Get sandbox provider configuration
 * Returns the active sandbox provider and available presets for environment creation
 */
export const getApiConfigSandboxOptions = (options?: Options<GetApiConfigSandboxData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiConfigSandbox({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiConfigSandboxQueryKey(options)
    });
};

export const getApiWorkspaceConfigsQueryKey = (options: Options<GetApiWorkspaceConfigsData>) => createQueryKey('getApiWorkspaceConfigs', options);

/**
 * Get workspace configuration
 */
export const getApiWorkspaceConfigsOptions = (options: Options<GetApiWorkspaceConfigsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiWorkspaceConfigs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiWorkspaceConfigsQueryKey(options)
    });
};

/**
 * Create or update workspace configuration
 */
export const postApiWorkspaceConfigsMutation = (options?: Partial<Options<PostApiWorkspaceConfigsData>>): UseMutationOptions<PostApiWorkspaceConfigsResponse, DefaultError, Options<PostApiWorkspaceConfigsData>> => {
    const mutationOptions: UseMutationOptions<PostApiWorkspaceConfigsResponse, DefaultError, Options<PostApiWorkspaceConfigsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiWorkspaceConfigs({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiPreviewConfigsQueryKey = (options: Options<GetApiPreviewConfigsData>) => createQueryKey('getApiPreviewConfigs', options);

/**
 * List preview configurations for a team
 */
export const getApiPreviewConfigsOptions = (options: Options<GetApiPreviewConfigsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiPreviewConfigs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPreviewConfigsQueryKey(options)
    });
};

/**
 * Create or update a preview configuration
 */
export const postApiPreviewConfigsMutation = (options?: Partial<Options<PostApiPreviewConfigsData>>): UseMutationOptions<PostApiPreviewConfigsResponse, DefaultError, Options<PostApiPreviewConfigsData>> => {
    const mutationOptions: UseMutationOptions<PostApiPreviewConfigsResponse, DefaultError, Options<PostApiPreviewConfigsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPreviewConfigs({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a preview configuration
 */
export const deleteApiPreviewConfigsByPreviewConfigIdMutation = (options?: Partial<Options<DeleteApiPreviewConfigsByPreviewConfigIdData>>): UseMutationOptions<DeleteApiPreviewConfigsByPreviewConfigIdResponse, DefaultError, Options<DeleteApiPreviewConfigsByPreviewConfigIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiPreviewConfigsByPreviewConfigIdResponse, DefaultError, Options<DeleteApiPreviewConfigsByPreviewConfigIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiPreviewConfigsByPreviewConfigId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiPreviewConfigsByPreviewConfigIdRunsQueryKey = (options: Options<GetApiPreviewConfigsByPreviewConfigIdRunsData>) => createQueryKey('getApiPreviewConfigsByPreviewConfigIdRuns', options);

/**
 * List recent preview runs for a configuration
 */
export const getApiPreviewConfigsByPreviewConfigIdRunsOptions = (options: Options<GetApiPreviewConfigsByPreviewConfigIdRunsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiPreviewConfigsByPreviewConfigIdRuns({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPreviewConfigsByPreviewConfigIdRunsQueryKey(options)
    });
};

export const getApiPreviewTestCheckAccessQueryKey = (options: Options<GetApiPreviewTestCheckAccessData>) => createQueryKey('getApiPreviewTestCheckAccess', options);

/**
 * Check if team has GitHub access to the repository in a PR URL
 */
export const getApiPreviewTestCheckAccessOptions = (options: Options<GetApiPreviewTestCheckAccessData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiPreviewTestCheckAccess({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPreviewTestCheckAccessQueryKey(options)
    });
};

export const getApiPreviewTestJobsQueryKey = (options: Options<GetApiPreviewTestJobsData>) => createQueryKey('getApiPreviewTestJobs', options);

/**
 * List test preview jobs for a team
 */
export const getApiPreviewTestJobsOptions = (options: Options<GetApiPreviewTestJobsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiPreviewTestJobs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPreviewTestJobsQueryKey(options)
    });
};

/**
 * Create a test preview job from a PR URL (fetches real PR data from GitHub)
 */
export const postApiPreviewTestJobsMutation = (options?: Partial<Options<PostApiPreviewTestJobsData>>): UseMutationOptions<PostApiPreviewTestJobsResponse, DefaultError, Options<PostApiPreviewTestJobsData>> => {
    const mutationOptions: UseMutationOptions<PostApiPreviewTestJobsResponse, DefaultError, Options<PostApiPreviewTestJobsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPreviewTestJobs({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Start a test preview job (trigger screenshot capture)
 */
export const postApiPreviewTestJobsByPreviewRunIdDispatchMutation = (options?: Partial<Options<PostApiPreviewTestJobsByPreviewRunIdDispatchData>>): UseMutationOptions<PostApiPreviewTestJobsByPreviewRunIdDispatchResponse, DefaultError, Options<PostApiPreviewTestJobsByPreviewRunIdDispatchData>> => {
    const mutationOptions: UseMutationOptions<PostApiPreviewTestJobsByPreviewRunIdDispatchResponse, DefaultError, Options<PostApiPreviewTestJobsByPreviewRunIdDispatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPreviewTestJobsByPreviewRunIdDispatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a test preview job
 */
export const deleteApiPreviewTestJobsByPreviewRunIdMutation = (options?: Partial<Options<DeleteApiPreviewTestJobsByPreviewRunIdData>>): UseMutationOptions<DeleteApiPreviewTestJobsByPreviewRunIdResponse, DefaultError, Options<DeleteApiPreviewTestJobsByPreviewRunIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiPreviewTestJobsByPreviewRunIdResponse, DefaultError, Options<DeleteApiPreviewTestJobsByPreviewRunIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiPreviewTestJobsByPreviewRunId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiPreviewTestJobsByPreviewRunIdQueryKey = (options: Options<GetApiPreviewTestJobsByPreviewRunIdData>) => createQueryKey('getApiPreviewTestJobsByPreviewRunId', options);

/**
 * Get detailed info about a test preview job
 */
export const getApiPreviewTestJobsByPreviewRunIdOptions = (options: Options<GetApiPreviewTestJobsByPreviewRunIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiPreviewTestJobsByPreviewRunId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiPreviewTestJobsByPreviewRunIdQueryKey(options)
    });
};

/**
 * Retry a failed test preview job (creates new run and dispatches)
 */
export const postApiPreviewTestJobsByPreviewRunIdRetryMutation = (options?: Partial<Options<PostApiPreviewTestJobsByPreviewRunIdRetryData>>): UseMutationOptions<PostApiPreviewTestJobsByPreviewRunIdRetryResponse, DefaultError, Options<PostApiPreviewTestJobsByPreviewRunIdRetryData>> => {
    const mutationOptions: UseMutationOptions<PostApiPreviewTestJobsByPreviewRunIdRetryResponse, DefaultError, Options<PostApiPreviewTestJobsByPreviewRunIdRetryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiPreviewTestJobsByPreviewRunIdRetry({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Clear user's editor settings
 */
export const deleteApiEditorSettingsMutation = (options?: Partial<Options<DeleteApiEditorSettingsData>>): UseMutationOptions<DeleteApiEditorSettingsResponse, DefaultError, Options<DeleteApiEditorSettingsData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiEditorSettingsResponse, DefaultError, Options<DeleteApiEditorSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiEditorSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiEditorSettingsQueryKey = (options: Options<GetApiEditorSettingsData>) => createQueryKey('getApiEditorSettings', options);

/**
 * Get user's editor settings
 */
export const getApiEditorSettingsOptions = (options: Options<GetApiEditorSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiEditorSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiEditorSettingsQueryKey(options)
    });
};

/**
 * Create or update user's editor settings
 */
export const postApiEditorSettingsMutation = (options?: Partial<Options<PostApiEditorSettingsData>>): UseMutationOptions<PostApiEditorSettingsResponse, DefaultError, Options<PostApiEditorSettingsData>> => {
    const mutationOptions: UseMutationOptions<PostApiEditorSettingsResponse, DefaultError, Options<PostApiEditorSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiEditorSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test Anthropic base URL and API key connectivity
 */
export const postApiSettingsTestAnthropicConnectionMutation = (options?: Partial<Options<PostApiSettingsTestAnthropicConnectionData>>): UseMutationOptions<PostApiSettingsTestAnthropicConnectionResponse, DefaultError, Options<PostApiSettingsTestAnthropicConnectionData>> => {
    const mutationOptions: UseMutationOptions<PostApiSettingsTestAnthropicConnectionResponse, DefaultError, Options<PostApiSettingsTestAnthropicConnectionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiSettingsTestAnthropicConnection({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a worktree from the registry
 * Removes a worktree entry from the registry. Note: This only removes the registry entry, not the actual filesystem worktree.
 */
export const postApiWorktreesRemoveMutation = (options?: Partial<Options<PostApiWorktreesRemoveData>>): UseMutationOptions<PostApiWorktreesRemoveResponse, DefaultError, Options<PostApiWorktreesRemoveData>> => {
    const mutationOptions: UseMutationOptions<PostApiWorktreesRemoveResponse, DefaultError, Options<PostApiWorktreesRemoveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiWorktreesRemove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiModelsQueryKey = (options: Options<GetApiModelsData>) => createQueryKey('getApiModels', options);

/**
 * List all models for admin management
 */
export const getApiModelsOptions = (options: Options<GetApiModelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiModels({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiModelsQueryKey(options)
    });
};

/**
 * Toggle model enabled state
 */
export const patchApiModelsByNameEnabledMutation = (options?: Partial<Options<PatchApiModelsByNameEnabledData>>): UseMutationOptions<PatchApiModelsByNameEnabledResponse, DefaultError, Options<PatchApiModelsByNameEnabledData>> => {
    const mutationOptions: UseMutationOptions<PatchApiModelsByNameEnabledResponse, DefaultError, Options<PatchApiModelsByNameEnabledData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiModelsByNameEnabled({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reorder models
 */
export const postApiModelsReorderMutation = (options?: Partial<Options<PostApiModelsReorderData>>): UseMutationOptions<PostApiModelsReorderResponse, DefaultError, Options<PostApiModelsReorderData>> => {
    const mutationOptions: UseMutationOptions<PostApiModelsReorderResponse, DefaultError, Options<PostApiModelsReorderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiModelsReorder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Trigger model discovery
 */
export const postApiModelsRefreshMutation = (options?: Partial<Options<PostApiModelsRefreshData>>): UseMutationOptions<PostApiModelsRefreshResponse, DefaultError, Options<PostApiModelsRefreshData>> => {
    const mutationOptions: UseMutationOptions<PostApiModelsRefreshResponse, DefaultError, Options<PostApiModelsRefreshData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiModelsRefresh({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Seed curated models from AGENT_CATALOG
 */
export const postApiModelsSeedMutation = (options?: Partial<Options<PostApiModelsSeedData>>): UseMutationOptions<PostApiModelsSeedResponse, DefaultError, Options<PostApiModelsSeedData>> => {
    const mutationOptions: UseMutationOptions<PostApiModelsSeedResponse, DefaultError, Options<PostApiModelsSeedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiModelsSeed({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiProvidersQueryKey = (options: Options<GetApiProvidersData>) => createQueryKey('getApiProviders', options);

/**
 * List provider overrides for team
 */
export const getApiProvidersOptions = (options: Options<GetApiProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiProvidersQueryKey(options)
    });
};

/**
 * Delete a provider override
 */
export const deleteApiProvidersByIdMutation = (options?: Partial<Options<DeleteApiProvidersByIdData>>): UseMutationOptions<DeleteApiProvidersByIdResponse, DefaultError, Options<DeleteApiProvidersByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiProvidersByIdResponse, DefaultError, Options<DeleteApiProvidersByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiProvidersById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiProvidersByIdQueryKey = (options: Options<GetApiProvidersByIdData>) => createQueryKey('getApiProvidersById', options);

/**
 * Get a specific provider override
 */
export const getApiProvidersByIdOptions = (options: Options<GetApiProvidersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiProvidersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiProvidersByIdQueryKey(options)
    });
};

/**
 * Create or update a provider override
 */
export const putApiProvidersByIdMutation = (options?: Partial<Options<PutApiProvidersByIdData>>): UseMutationOptions<PutApiProvidersByIdResponse, DefaultError, Options<PutApiProvidersByIdData>> => {
    const mutationOptions: UseMutationOptions<PutApiProvidersByIdResponse, DefaultError, Options<PutApiProvidersByIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putApiProvidersById({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test provider connectivity
 */
export const postApiProvidersByIdTestMutation = (options?: Partial<Options<PostApiProvidersByIdTestData>>): UseMutationOptions<PostApiProvidersByIdTestResponse, DefaultError, Options<PostApiProvidersByIdTestData>> => {
    const mutationOptions: UseMutationOptions<PostApiProvidersByIdTestResponse, DefaultError, Options<PostApiProvidersByIdTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiProvidersByIdTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Toggle provider enabled state
 */
export const patchApiProvidersByIdEnabledMutation = (options?: Partial<Options<PatchApiProvidersByIdEnabledData>>): UseMutationOptions<PatchApiProvidersByIdEnabledResponse, DefaultError, Options<PatchApiProvidersByIdEnabledData>> => {
    const mutationOptions: UseMutationOptions<PatchApiProvidersByIdEnabledResponse, DefaultError, Options<PatchApiProvidersByIdEnabledData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiProvidersByIdEnabled({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiProvidersStatusQueryKey = (options: Options<GetApiProvidersStatusData>) => createQueryKey('getApiProvidersStatus', options);

/**
 * Get provider availability status
 */
export const getApiProvidersStatusOptions = (options: Options<GetApiProvidersStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiProvidersStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiProvidersStatusQueryKey(options)
    });
};

export const getApiApiKeysQueryKey = (options: Options<GetApiApiKeysData>) => createQueryKey('getApiApiKeys', options);

/**
 * List all API keys for team (masked values)
 */
export const getApiApiKeysOptions = (options: Options<GetApiApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiApiKeysQueryKey(options)
    });
};

/**
 * Create or update an API key
 */
export const putApiApiKeysMutation = (options?: Partial<Options<PutApiApiKeysData>>): UseMutationOptions<PutApiApiKeysResponse, DefaultError, Options<PutApiApiKeysData>> => {
    const mutationOptions: UseMutationOptions<PutApiApiKeysResponse, DefaultError, Options<PutApiApiKeysData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putApiApiKeys({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an API key
 */
export const deleteApiApiKeysByEnvVarMutation = (options?: Partial<Options<DeleteApiApiKeysByEnvVarData>>): UseMutationOptions<DeleteApiApiKeysByEnvVarResponse, DefaultError, Options<DeleteApiApiKeysByEnvVarData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiApiKeysByEnvVarResponse, DefaultError, Options<DeleteApiApiKeysByEnvVarData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApiApiKeysByEnvVar({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};