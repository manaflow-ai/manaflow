# TanStack Query

TanStack Query (formerly React Query) is a powerful asynchronous state management library for fetching, caching, synchronizing, and updating server state in JavaScript applications. It provides hooks and utilities that simplify data fetching by handling caching, background updates, stale data management, pagination, infinite scrolling, and optimistic updates out of the box. The library is framework-agnostic at its core (`@tanstack/query-core`) with dedicated adapters for React, Vue, Solid, Svelte, and Angular.

The library eliminates the need for manual cache management by automatically handling data freshness, background refetching, garbage collection, and request deduplication. It supports both REST and GraphQL APIs (or any promise-based data fetching), provides built-in devtools for debugging, and integrates seamlessly with React Suspense for concurrent rendering patterns. Version 5.x introduces simplified APIs with object-only syntax, improved TypeScript support, and dedicated suspense hooks.

## QueryClientProvider - Application Setup

The QueryClientProvider component connects a QueryClient instance to your React application, making it available to all child components via context. This is required at the root of your application before using any query hooks.

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

// Create a client with default options
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 30, // 30 minutes (garbage collection time)
      retry: 3,
      refetchOnWindowFocus: true,
    },
    mutations: {
      retry: 1,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

## useQuery - Basic Data Fetching

The useQuery hook fetches and caches data based on a unique query key. It automatically handles loading states, errors, caching, background refetching, and data freshness. The query key is used for caching and can include variables that trigger refetches when changed.

```tsx
import { useQuery } from '@tanstack/react-query'

interface Todo {
  id: number
  title: string
  completed: boolean
}

function TodoList() {
  const {
    data,
    isPending,
    isError,
    error,
    isFetching,
    refetch,
  } = useQuery<Todo[], Error>({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Network response was not ok')
      }
      return response.json()
    },
    staleTime: 1000 * 60, // Data considered fresh for 1 minute
    gcTime: 1000 * 60 * 5, // Cache kept for 5 minutes after becoming unused
    refetchOnWindowFocus: true,
    refetchInterval: false, // Set to number for polling
  })

  if (isPending) return <div>Loading...</div>
  if (isError) return <div>Error: {error.message}</div>

  return (
    <div>
      {isFetching && <span>Refreshing...</span>}
      <button onClick={() => refetch()}>Refresh</button>
      <ul>
        {data.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

## useQuery with Variables - Dynamic Query Keys

Query keys can include variables to fetch different data based on parameters. When variables change, TanStack Query automatically refetches with the new values while keeping previous data cached.

```tsx
import { useQuery } from '@tanstack/react-query'

interface User {
  id: number
  name: string
  email: string
}

function UserProfile({ userId }: { userId: number }) {
  const { data: user, isPending, isError } = useQuery<User>({
    queryKey: ['user', userId], // Query key includes userId
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`)
      if (!response.ok) throw new Error('Failed to fetch user')
      return response.json()
    },
    enabled: !!userId, // Only run query if userId is truthy
  })

  if (isPending) return <div>Loading user...</div>
  if (isError) return <div>Failed to load user</div>

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  )
}

// Using with filters and pagination
function FilteredTodos({ status, page }: { status: string; page: number }) {
  const { data } = useQuery({
    queryKey: ['todos', { status, page }],
    queryFn: () => fetchTodos({ status, page }),
    placeholderData: (previousData) => previousData, // Keep previous data while fetching
  })

  return <div>{/* render todos */}</div>
}
```

## useMutation - Creating, Updating, and Deleting Data

The useMutation hook handles data modifications with support for optimistic updates, error handling, and automatic cache invalidation. Unlike queries, mutations don't run automatically - they're triggered by calling the mutate function.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

interface CreateTodoInput {
  title: string
}

interface Todo {
  id: number
  title: string
  completed: boolean
}

function AddTodo() {
  const queryClient = useQueryClient()

  const mutation = useMutation<Todo, Error, CreateTodoInput>({
    mutationFn: async (newTodo) => {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo),
      })
      if (!response.ok) throw new Error('Failed to create todo')
      return response.json()
    },
    onSuccess: (data) => {
      // Invalidate and refetch todos list
      queryClient.invalidateQueries({ queryKey: ['todos'] })
      console.log('Created todo:', data)
    },
    onError: (error) => {
      console.error('Failed to create todo:', error.message)
    },
    onSettled: () => {
      // Runs on both success and error
      console.log('Mutation completed')
    },
  })

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    mutation.mutate({ title: formData.get('title') as string })
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="New todo" required />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Adding...' : 'Add Todo'}
      </button>
      {mutation.isError && <p style={{ color: 'red' }}>{mutation.error.message}</p>}
      {mutation.isSuccess && <p style={{ color: 'green' }}>Todo added!</p>}
    </form>
  )
}
```

## Optimistic Updates - Instant UI Feedback

Optimistic updates provide immediate UI feedback before the server confirms the change. If the mutation fails, TanStack Query can automatically roll back to the previous state.

```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'

interface Todo {
  id: number
  title: string
  completed: boolean
}

function TodoItem({ todo }: { todo: Todo }) {
  const queryClient = useQueryClient()

  const toggleMutation = useMutation({
    mutationFn: async (updatedTodo: Todo) => {
      const response = await fetch(`/api/todos/${updatedTodo.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: updatedTodo.completed }),
      })
      return response.json()
    },
    // Optimistic update
    onMutate: async (newTodo, context) => {
      // Cancel outgoing refetches
      await context.client.cancelQueries({ queryKey: ['todos'] })

      // Snapshot previous value
      const previousTodos = context.client.getQueryData<Todo[]>(['todos'])

      // Optimistically update cache
      context.client.setQueryData<Todo[]>(['todos'], (old) =>
        old?.map((t) => (t.id === newTodo.id ? newTodo : t))
      )

      // Return snapshot for rollback
      return { previousTodos }
    },
    onError: (err, newTodo, onMutateResult, context) => {
      // Rollback on error
      context.client.setQueryData(['todos'], onMutateResult?.previousTodos)
    },
    onSettled: (data, error, variables, onMutateResult, context) => {
      // Always refetch after error or success
      context.client.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <label>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() =>
          toggleMutation.mutate({ ...todo, completed: !todo.completed })
        }
      />
      {todo.title}
    </label>
  )
}
```

## useInfiniteQuery - Infinite Scroll and Pagination

The useInfiniteQuery hook handles paginated data that can grow infinitely, perfect for infinite scroll implementations. It manages multiple pages of data and provides functions to fetch more.

```tsx
import { useInfiniteQuery } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useInView } from 'react-intersection-observer'

interface ProjectsPage {
  data: Array<{ id: number; name: string }>
  nextCursor: number | null
}

function ProjectList() {
  const { ref, inView } = useInView()

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery<ProjectsPage>({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      const response = await fetch(`/api/projects?cursor=${pageParam}`)
      return response.json()
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,
    // Optional: limit stored pages for memory optimization
    maxPages: 5,
    // Optional: enable bi-directional scrolling
    getPreviousPageParam: (firstPage) => firstPage.prevCursor ?? undefined,
  })

  // Auto-fetch when scroll indicator is visible
  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage()
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage])

  if (status === 'pending') return <p>Loading...</p>
  if (status === 'error') return <p>Error: {error.message}</p>

  return (
    <div>
      {data.pages.map((page, pageIndex) => (
        <div key={pageIndex}>
          {page.data.map((project) => (
            <div key={project.id}>{project.name}</div>
          ))}
        </div>
      ))}

      <div ref={ref}>
        {isFetchingNextPage
          ? 'Loading more...'
          : hasNextPage
          ? 'Load More'
          : 'No more projects'}
      </div>

      {isFetching && !isFetchingNextPage && <span>Refreshing...</span>}
    </div>
  )
}
```

## QueryClient Methods - Programmatic Cache Control

The QueryClient provides methods for programmatically interacting with the cache, including prefetching, invalidation, and direct cache manipulation.

```tsx
import { useQueryClient } from '@tanstack/react-query'

function CacheManagement() {
  const queryClient = useQueryClient()

  // Prefetch data before it's needed
  const prefetchUser = async (userId: number) => {
    await queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
      staleTime: 1000 * 60 * 5, // Only prefetch if data is older than 5 minutes
    })
  }

  // Invalidate queries to trigger refetch
  const invalidateAllTodos = () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  }

  // Invalidate with specific filters
  const invalidateCompletedTodos = () => {
    queryClient.invalidateQueries({
      queryKey: ['todos'],
      predicate: (query) =>
        query.queryKey[0] === 'todos' &&
        (query.state.data as any)?.completed === true,
    })
  }

  // Get cached data synchronously
  const getCachedUser = (userId: number) => {
    return queryClient.getQueryData(['user', userId])
  }

  // Set cached data directly
  const updateCachedUser = (userId: number, updates: Partial<User>) => {
    queryClient.setQueryData(['user', userId], (old: User | undefined) =>
      old ? { ...old, ...updates } : undefined
    )
  }

  // Fetch data and return it (unlike prefetch which returns void)
  const fetchUser = async (userId: number) => {
    return queryClient.fetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
    })
  }

  // Ensure data exists (fetch if missing, return cached if present)
  const ensureUser = async (userId: number) => {
    return queryClient.ensureQueryData({
      queryKey: ['user', userId],
      queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
    })
  }

  // Cancel ongoing queries
  const cancelUserQueries = async () => {
    await queryClient.cancelQueries({ queryKey: ['user'] })
  }

  // Remove queries from cache
  const clearUserCache = () => {
    queryClient.removeQueries({ queryKey: ['user'] })
  }

  // Reset queries to initial state
  const resetTodos = () => {
    queryClient.resetQueries({ queryKey: ['todos'] })
  }

  // Refetch all matching queries
  const refetchAllStale = async () => {
    await queryClient.refetchQueries({ stale: true })
  }

  return (
    <button onMouseEnter={() => prefetchUser(123)}>
      Hover to prefetch user
    </button>
  )
}
```

## useSuspenseQuery - React Suspense Integration

The useSuspenseQuery hook integrates with React Suspense for declarative loading states. Data is guaranteed to be defined when the component renders, eliminating null checks.

```tsx
import { Suspense } from 'react'
import { useSuspenseQuery, QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

interface User {
  id: number
  name: string
}

function UserDetails({ userId }: { userId: number }) {
  // data is guaranteed to be defined - no isPending or isError needed
  const { data } = useSuspenseQuery<User>({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`)
      if (!response.ok) throw new Error('Failed to fetch user')
      return response.json()
    },
  })

  return (
    <div>
      <h1>{data.name}</h1>
    </div>
  )
}

function App() {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ error, resetErrorBoundary }) => (
            <div>
              <p>Something went wrong: {error.message}</p>
              <button onClick={resetErrorBoundary}>Try again</button>
            </div>
          )}
        >
          <Suspense fallback={<div>Loading user...</div>}>
            <UserDetails userId={1} />
          </Suspense>
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  )
}

// Multiple suspense queries in parallel
function Dashboard() {
  return (
    <Suspense fallback={<div>Loading dashboard...</div>}>
      <DashboardContent />
    </Suspense>
  )
}

function DashboardContent() {
  // Both queries run in parallel, component suspends until both resolve
  const { data: user } = useSuspenseQuery({
    queryKey: ['currentUser'],
    queryFn: fetchCurrentUser,
  })

  const { data: stats } = useSuspenseQuery({
    queryKey: ['userStats', user.id],
    queryFn: () => fetchUserStats(user.id),
  })

  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <p>Total posts: {stats.postCount}</p>
    </div>
  )
}
```

## Query Invalidation - Cache Freshness Control

Query invalidation marks cached data as stale and optionally triggers a refetch. This is commonly used after mutations to ensure displayed data is up-to-date.

```tsx
import { useQueryClient, useMutation, useQuery } from '@tanstack/react-query'

function TodoApp() {
  const queryClient = useQueryClient()

  // Invalidate by exact key
  const invalidateExact = () => {
    queryClient.invalidateQueries({ queryKey: ['todos'], exact: true })
  }

  // Invalidate all queries starting with 'todos'
  const invalidatePrefix = () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  }

  // Invalidate with predicate function
  const invalidateByPredicate = () => {
    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' &&
        (query.queryKey[1] as any)?.status === 'pending',
    })
  }

  // Common pattern: invalidate after mutation
  const addTodoMutation = useMutation({
    mutationFn: createTodo,
    onSuccess: () => {
      // Invalidate todos to refetch the list
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  // Update cache directly after mutation (without refetch)
  const updateTodoMutation = useMutation({
    mutationFn: updateTodo,
    onSuccess: (updatedTodo) => {
      // Update the specific todo in cache
      queryClient.setQueryData(['todos', updatedTodo.id], updatedTodo)
      // Also update it in any list caches
      queryClient.setQueriesData(
        { queryKey: ['todos'] },
        (old: Todo[] | undefined) =>
          old?.map((t) => (t.id === updatedTodo.id ? updatedTodo : t))
      )
    },
  })

  // Invalidate without refetching active queries
  const markStaleOnly = () => {
    queryClient.invalidateQueries({
      queryKey: ['todos'],
      refetchType: 'none', // Just mark as stale, don't refetch
    })
  }

  return <div>{/* UI */}</div>
}
```

## Dependent Queries - Sequential Data Fetching

Dependent queries only execute when a condition is met, typically when data from a previous query is available. This enables sequential data fetching where one query depends on another.

```tsx
import { useQuery } from '@tanstack/react-query'

interface User {
  id: number
  name: string
  teamId: number
}

interface Team {
  id: number
  name: string
  members: number[]
}

function UserTeamInfo({ userId }: { userId: number }) {
  // First query: fetch user
  const userQuery = useQuery<User>({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then((r) => r.json()),
  })

  // Second query: fetch team (depends on user data)
  const teamQuery = useQuery<Team>({
    queryKey: ['team', userQuery.data?.teamId],
    queryFn: () =>
      fetch(`/api/teams/${userQuery.data!.teamId}`).then((r) => r.json()),
    // Only run this query when we have the user's teamId
    enabled: !!userQuery.data?.teamId,
  })

  if (userQuery.isPending) return <div>Loading user...</div>
  if (userQuery.isError) return <div>Error loading user</div>

  return (
    <div>
      <h1>{userQuery.data.name}</h1>
      {teamQuery.isPending ? (
        <p>Loading team...</p>
      ) : teamQuery.isError ? (
        <p>Error loading team</p>
      ) : (
        <p>Team: {teamQuery.data.name}</p>
      )}
    </div>
  )
}

// Using enabled with a function for dynamic conditions
function ConditionalQuery({ shouldFetch }: { shouldFetch: boolean }) {
  const { data } = useQuery({
    queryKey: ['conditionalData'],
    queryFn: fetchData,
    enabled: (query) => {
      // Can access query state for complex conditions
      return shouldFetch && !query.state.data
    },
  })

  return <div>{/* render */}</div>
}
```

## Parallel Queries - Fetching Multiple Resources

Multiple useQuery hooks in the same component run in parallel automatically. For dynamic parallel queries, use the useQueries hook.

```tsx
import { useQuery, useQueries } from '@tanstack/react-query'

// Static parallel queries - just use multiple useQuery calls
function Dashboard() {
  const usersQuery = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  })

  const projectsQuery = useQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
  })

  const statsQuery = useQuery({
    queryKey: ['stats'],
    queryFn: fetchStats,
  })

  const isLoading =
    usersQuery.isPending || projectsQuery.isPending || statsQuery.isPending

  if (isLoading) return <div>Loading dashboard...</div>

  return (
    <div>
      <UserList users={usersQuery.data} />
      <ProjectList projects={projectsQuery.data} />
      <Stats stats={statsQuery.data} />
    </div>
  )
}

// Dynamic parallel queries - use useQueries
function UsersList({ userIds }: { userIds: number[] }) {
  const userQueries = useQueries({
    queries: userIds.map((id) => ({
      queryKey: ['user', id],
      queryFn: () => fetchUser(id),
      staleTime: 1000 * 60 * 5,
    })),
    // Optional: combine results
    combine: (results) => ({
      data: results.map((r) => r.data).filter(Boolean),
      pending: results.some((r) => r.isPending),
      error: results.find((r) => r.isError)?.error,
    }),
  })

  if (userQueries.pending) return <div>Loading users...</div>
  if (userQueries.error) return <div>Error: {userQueries.error.message}</div>

  return (
    <ul>
      {userQueries.data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  )
}
```

## Query Options Factory - Reusable Query Configurations

The queryOptions helper creates type-safe, reusable query configurations that can be shared between useQuery, prefetching, and cache operations.

```tsx
import { queryOptions, useQuery, useQueryClient } from '@tanstack/react-query'

// Define reusable query options
const todoQueryOptions = (todoId: number) =>
  queryOptions({
    queryKey: ['todo', todoId],
    queryFn: async () => {
      const response = await fetch(`/api/todos/${todoId}`)
      if (!response.ok) throw new Error('Failed to fetch todo')
      return response.json() as Promise<Todo>
    },
    staleTime: 1000 * 60 * 5,
  })

const todosListOptions = queryOptions({
  queryKey: ['todos'],
  queryFn: async () => {
    const response = await fetch('/api/todos')
    return response.json() as Promise<Todo[]>
  },
})

// Use in components
function TodoDetail({ todoId }: { todoId: number }) {
  const { data } = useQuery(todoQueryOptions(todoId))
  return <div>{data?.title}</div>
}

// Use for prefetching
function TodoListItem({ todo }: { todo: Todo }) {
  const queryClient = useQueryClient()

  return (
    <div
      onMouseEnter={() => {
        // Prefetch on hover using same options
        queryClient.prefetchQuery(todoQueryOptions(todo.id))
      }}
    >
      {todo.title}
    </div>
  )
}

// Use in loaders (e.g., React Router)
const todoLoader = (queryClient: QueryClient) => async ({ params }) => {
  const options = todoQueryOptions(Number(params.todoId))
  return queryClient.ensureQueryData(options)
}
```

## Select and Data Transformation

The select option transforms or filters query data before it reaches the component, without affecting the cached data. This enables derived state and component-specific data views.

```tsx
import { useQuery } from '@tanstack/react-query'
import { useCallback, useMemo } from 'react'

interface Todo {
  id: number
  title: string
  completed: boolean
  priority: 'low' | 'medium' | 'high'
}

function TodoStats() {
  // Select only the count of completed todos
  const { data: completedCount } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select: (todos: Todo[]) => todos.filter((t) => t.completed).length,
  })

  return <div>Completed: {completedCount}</div>
}

function HighPriorityTodos() {
  // Filter to only high priority incomplete todos
  // useCallback prevents unnecessary re-renders when select reference changes
  const selectHighPriority = useCallback(
    (todos: Todo[]) =>
      todos.filter((t) => t.priority === 'high' && !t.completed),
    []
  )

  const { data: highPriorityTodos } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select: selectHighPriority,
  })

  return (
    <ul>
      {highPriorityTodos?.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

function TodosByStatus({ status }: { status: 'completed' | 'pending' }) {
  // Dynamic select based on props
  const { data } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select: useCallback(
      (todos: Todo[]) =>
        todos.filter((t) =>
          status === 'completed' ? t.completed : !t.completed
        ),
      [status]
    ),
  })

  return <div>{data?.length} todos</div>
}
```

## Placeholder and Initial Data

Placeholder data provides temporary data while the real query loads, while initial data seeds the cache and can be used for SSR or known values.

```tsx
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Placeholder data - shown while loading, not persisted to cache
function TodoWithPlaceholder({ todoId }: { todoId: number }) {
  const { data, isPlaceholderData } = useQuery({
    queryKey: ['todo', todoId],
    queryFn: () => fetchTodo(todoId),
    placeholderData: {
      id: todoId,
      title: 'Loading...',
      completed: false,
    },
  })

  return (
    <div style={{ opacity: isPlaceholderData ? 0.5 : 1 }}>
      {data.title}
    </div>
  )
}

// Using previous data as placeholder (for pagination)
function PaginatedTodos({ page }: { page: number }) {
  const { data, isPlaceholderData } = useQuery({
    queryKey: ['todos', page],
    queryFn: () => fetchTodoPage(page),
    // keepPreviousData equivalent - use previous page data while loading next
    placeholderData: (previousData) => previousData,
  })

  return (
    <div>
      {isPlaceholderData && <span>Loading new page...</span>}
      {data?.map((todo) => <div key={todo.id}>{todo.title}</div>)}
    </div>
  )
}

// Initial data - persisted to cache, can come from SSR or other sources
function TodoWithInitialData({ todoId, serverData }: Props) {
  const { data } = useQuery({
    queryKey: ['todo', todoId],
    queryFn: () => fetchTodo(todoId),
    initialData: serverData,
    initialDataUpdatedAt: Date.now() - 10000, // Mark as 10 seconds old
    staleTime: 60000, // Will refetch if initial data is older than 1 minute
  })

  return <div>{data.title}</div>
}

// Initial data from cache
function TodoFromCache({ todoId }: { todoId: number }) {
  const queryClient = useQueryClient()

  const { data } = useQuery({
    queryKey: ['todo', todoId],
    queryFn: () => fetchTodo(todoId),
    initialData: () => {
      // Try to get from todos list cache
      const todos = queryClient.getQueryData<Todo[]>(['todos'])
      return todos?.find((t) => t.id === todoId)
    },
    initialDataUpdatedAt: () => {
      // Use the dataUpdatedAt from the todos query
      return queryClient.getQueryState(['todos'])?.dataUpdatedAt
    },
  })

  return <div>{data?.title}</div>
}
```

## Error Handling and Retry Configuration

TanStack Query provides comprehensive error handling with automatic retries, exponential backoff, and integration with error boundaries.

```tsx
import { useQuery, QueryClient, QueryClientProvider } from '@tanstack/react-query'

// Global error handling configuration
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      throwOnError: (error, query) => {
        // Only throw to error boundary for specific errors
        return error.message.includes('CRITICAL')
      },
    },
  },
  queryCache: new QueryCache({
    onError: (error, query) => {
      // Global error handler for logging
      console.error(`Query ${query.queryKey} failed:`, error)
      if (error.message.includes('401')) {
        // Handle auth errors globally
        redirectToLogin()
      }
    },
  }),
})

// Per-query error handling
function DataWithRetry() {
  const { data, error, isError, failureCount, refetch } = useQuery({
    queryKey: ['data'],
    queryFn: async () => {
      const response = await fetch('/api/data')
      if (!response.ok) {
        const error = new Error('Failed to fetch')
        error.status = response.status
        throw error
      }
      return response.json()
    },
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error.status >= 400 && error.status < 500) return false
      return failureCount < 3
    },
    retryDelay: (attemptIndex, error) => {
      // Longer delay for rate limiting
      if (error.status === 429) return 60000
      return Math.min(1000 * 2 ** attemptIndex, 30000)
    },
  })

  if (isError) {
    return (
      <div>
        <p>Error: {error.message}</p>
        <p>Failed attempts: {failureCount}</p>
        <button onClick={() => refetch()}>Try again</button>
      </div>
    )
  }

  return <div>{/* render data */}</div>
}

// Error boundary integration
function QueryWithErrorBoundary() {
  const { data } = useQuery({
    queryKey: ['critical-data'],
    queryFn: fetchCriticalData,
    throwOnError: true, // Errors propagate to nearest error boundary
  })

  return <div>{data}</div>
}
```

TanStack Query is ideal for applications that need to fetch, cache, and synchronize server state with minimal boilerplate. Common use cases include dashboards displaying real-time data, e-commerce sites with product catalogs and shopping carts, social media feeds with infinite scroll, admin panels with CRUD operations, and any application where data freshness and offline support are important. The library excels at reducing code complexity by replacing manual loading/error states, cache management, and request deduplication logic.

Integration patterns typically involve wrapping the application with QueryClientProvider, creating query option factories for reusable configurations, combining mutations with query invalidation for consistent data, and leveraging prefetching for improved perceived performance. For server-side rendering, TanStack Query provides hydration utilities that seamlessly transfer server-fetched data to the client cache. The framework adapters (React, Vue, Solid, Svelte, Angular) provide idiomatic hooks while sharing the same powerful core, making it easy to apply these patterns across different frontend frameworks.
